<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live2D AI åŠ©æ‰‹</title>
    <script src="./js/live2dcubismcore.min.js"></script>
    <script src="./js/live2d.min.js"></script>
    <script src="./js/pixi.min.js"></script>
    <script src="./js/cubism4.min.js"></script>
    <script src="./js/jquery-3.1.1.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }
        #background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background-color: #FFFFFF;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            transition: background-color 0.5s, background-image 0.5s;
        }
        #control {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-height: 90vh;
            overflow-y: auto;
            width: 320px;
            z-index: 1000;
        }
        .section {
            border-bottom: 1px solid #eee;
            padding: 10px 0;
            margin-bottom: 10px;
        }
        .section-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        #control label, #control input, #control select, #control button {
            margin: 5px 0;
            display: block;
        }
        #control input[type="text"],
        #control input[type="url"],
        #control input[type="search"],
        #control select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        #control button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }
        #control button:hover {
            background: #45a049;
        }
        #control button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        #text_talk {
            width: 100%;
            height: 150px;
            margin-top: 10px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            font-family: inherit;
        }
        .model-config {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 8px;
            align-items: center;
        }
        .chat-input {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        .chat-input input {
            flex: 1;
        }
        .audio-controls {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        .tts-settings {
            margin-top: 10px;
        }
        .volume-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }
        #audio-status {
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
        }
        .loading {
            color: #666;
            font-style: italic;
        }
        .bg-option {
            margin-top: 10px;
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .bg-input-group {
            margin-top: 10px;
        }
        #bg_type {
            margin-bottom: 10px;
        }
        .tabs {
            display: flex;
            margin-bottom: 10px;
        }
        .tab {
            padding: 5px 10px;
            cursor: pointer;
            border: 1px solid #ddd;
            border-radius: 4px 4px 0 0;
            background: #f5f5f5;
        }
        .tab.active {
            background: #fff;
            border-bottom: 1px solid #fff;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        #bg_image_preset {
            width: 100%;
            margin-bottom: 10px;
        }
        .dialog {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .dialog-content {
            background-color: white;
            margin: 10% auto;
            padding: 20px;
            border-radius: 8px;
            max-width: 600px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .close-btn {
            float: right;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.2em;
        }

        .alert {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }

        .alert-danger {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .alert-success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }

        .secondary-button {
            background-color: #6c757d;
            color: white;
        }

        .dialog-actions {
            margin-top: 15px;
            text-align: right;
        }

        /* æ–°å¢ï¼šå£å‹åŒæ­¥æ§åˆ¶æ ·å¼ */
        .lipsync-settings {
            margin-top: 5px;
        }

        .control-group {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group label {
            flex: 0 0 120px;
        }

        .control-group input[type="range"] {
            flex: 1;
        }

        .control-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin: 0;
            display: inline-block;
        }

        #mouth-value {
            min-width: 30px;
            text-align: right;
        }

        /* ç¾åŒ–èŒƒå›´æ»‘å— */
        input[type="range"] {
            height: 8px;
            border-radius: 4px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: none;
        }

        /* è¯­éŸ³è¯†åˆ«ç›¸å…³æ ·å¼ */
        #voice_input {
            background-color: #4CAF50;
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #voice_input:hover {
            background-color: #45a049;
        }

        #voice_input.recording {
            background-color: #f44336;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .voice-recognition-status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            background-color: #f5f5f5;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .voice-wave {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 30px;
            margin-bottom: 5px;
        }

        .voice-wave span {
            display: inline-block;
            width: 3px;
            height: 5px;
            margin: 0 2px;
            background-color: #4CAF50;
            border-radius: 1px;
            animation: wave 1s infinite ease-in-out;
        }

        .voice-wave span:nth-child(2) {
            animation-delay: 0.1s;
        }

        .voice-wave span:nth-child(3) {
            animation-delay: 0.2s;
        }

        .voice-wave span:nth-child(4) {
            animation-delay: 0.3s;
        }

        .voice-wave span:nth-child(5) {
            animation-delay: 0.4s;
        }

        @keyframes wave {
            0%, 100% { height: 5px; }
            50% { height: 20px; }
        }

        .voice-text {
            font-size: 14px;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="background"></div>
    <canvas id="canvas"></canvas>

    <div id="control">
        <div class="section">
            <div class="section-title">æ¨¡å‹æ§åˆ¶</div>
            <div class="model-selection">
                <label for="model_list">é€‰æ‹©æ¨¡å‹:</label>
                <select id="model_list">
                    <option value="March 7th">March 7th</option>
                    <option value="kei_vowels_pro">kei_vowels_pro</option>
                    <option value="Nova - F">Nova - F</option>
                    <option value="Hiyori">Hiyori</option>
                    <option value="pachan">pachan</option>
                    <option value="EVA RIN normal">EVA RIN normal</option>
                </select>
                <button id="update_model">æ›´æ–°æ¨¡å‹</button>
                <button id="check_lfs" class="secondary-button">æ£€æŸ¥æ¨¡å‹æ–‡ä»¶</button>
            </div>
        </div>

        <div class="section">
            <div class="section-title">è¯­éŸ³è®¾ç½®</div>
            <div class="tabs">
                <div class="tab active" data-tab="tts">è¯­éŸ³åˆæˆ</div>
                <div class="tab" data-tab="stt">è¯­éŸ³è¯†åˆ«</div>
            </div>

            <div class="tab-content active" id="tts-tab">
                <div class="tts-settings">
                    <select id="voice_selection">
                        <option value="21m00Tcm4TlvDq8ikWAM">chinese (ä¸­æ–‡)</option>
                        <option value="AZnzlk1XvdvUeBnXmlld">Endlish (è‹±è¯­)</option>
                    </select>
                    <div class="volume-control">
                        <label for="volume">éŸ³é‡:</label>
                        <input type="range" id="volume" min="0" max="1" step="0.1" value="0.7">
                        <span id="volume-value">70%</span>
                    </div>
                </div>
            </div>

            <div class="tab-content" id="stt-tab">
                <div class="voice-recognition-settings">
                    <div class="control-group">
                        <label for="voice_recognition_enabled">å¯ç”¨è¯­éŸ³è¯†åˆ«:</label>
                        <input type="checkbox" id="voice_recognition_enabled" checked>
                    </div>
                    <div class="control-group">
                        <label for="voice_recognition_mode">è¯†åˆ«æ¨¡å¼:</label>
                        <select id="voice_recognition_mode">
                            <option value="server">æœåŠ¡å™¨æ¨¡å¼ (é«˜ç²¾åº¦)</option>
                            <option value="browser">æµè§ˆå™¨æ¨¡å¼ (ä½å»¶è¿Ÿ)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="voice_recognition_language">è¯­è¨€:</label>
                        <select id="voice_recognition_language">
                            <option value="zh">ä¸­æ–‡</option>
                            <option value="en">è‹±è¯­</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="auto_send_voice">è‡ªåŠ¨å‘é€:</label>
                        <input type="checkbox" id="auto_send_voice" checked>
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">å£å‹åŒæ­¥è®¾ç½®</div>
            <div class="lipsync-settings">
                <div class="control-group">
                    <label for="lipsync_enabled">å¯ç”¨å£å‹åŒæ­¥:</label>
                    <input type="checkbox" id="lipsync_enabled" checked>
                </div>
                <div class="control-group">
                    <label for="mouth_intensity">å˜´å·´å¼€åˆå¼ºåº¦:</label>
                    <input type="range" id="mouth_intensity" min="0.5" max="2.5" step="0.1" value="1.5">
                    <span id="mouth-value">1.5</span>
                </div>
                <div class="control-group">
                    <label for="blink_frequency">çœ¨çœ¼é¢‘ç‡:</label>
                    <select id="blink_frequency">
                        <option value="high">é«˜é¢‘ç‡</option>
                        <option value="medium" selected>ä¸­é¢‘ç‡</option>
                        <option value="low">ä½é¢‘ç‡</option>
                        <option value="none">ä¸çœ¨çœ¼</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Ollama é…ç½®</div>
            <div class="model-config">
                <label for="llm_model">è¯­è¨€æ¨¡å‹:</label>
                <select id="llm_model">
                    <option value="deepseek-r1:7b">deepseek-r1:7b</option>
                    <option value="qwen2:0.5b">Qwen2 0.5B</option>
                    <option value="llama2:7b">LLaMA2 7B</option>
                </select>

                <label for="temperature">æ¸©åº¦:</label>
                <input type="range" id="temperature" min="0" max="1" step="0.1" value="0.7">

                <label for="top_p">Top P:</label>
                <input type="range" id="top_p" min="0" max="1" step="0.1" value="0.9">
            </div>
        </div>

        <div class="section">
            <div class="section-title">è§’è‰²è®¾å®š</div>
            <label for="role_prompt">è§’è‰²è®¾å®š:</label>
            <textarea id="role_prompt" rows="3" style="width: 100%">ä¸€ä¸ªAIåŠ©æ‰‹ï¼Œä¼šè®¤çœŸå›ç­”æ‚¨çš„é—®é¢˜ã€‚</textarea>
        </div>

        <div class="section">
            <div class="section-title">å¯¹è¯</div>
            <div class="chat-container">
                <textarea id="text_talk" readonly placeholder="å¯¹è¯å†å²å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..."></textarea>
                <div class="chat-input">
                    <input type="text" id="user_input" placeholder="è¾“å…¥æ‚¨çš„é—®é¢˜...">
                    <button id="voice_input" title="è¯­éŸ³è¾“å…¥"><i class="fa fa-microphone"></i></button>
                    <button id="send_message">å‘é€</button>
                </div>
                <div class="voice-recognition-status" id="voice_status" style="display: none;">
                    <div class="voice-wave">
                        <span></span><span></span><span></span><span></span><span></span>
                    </div>
                    <div class="voice-text">æ­£åœ¨è†å¬...</div>
                </div>
                <div class="audio-controls">
                    <button id="play_audio" disabled>æ’­æ”¾è¯­éŸ³</button>
                    <button id="stop_audio" disabled>åœæ­¢è¯­éŸ³</button>
                </div>
                <div id="audio-status"></div>
            </div>
        </div>

        <!-- é«˜çº§æƒ…æ„Ÿç³»ç»Ÿ -->
        <div class="section">
            <div class="section-title">ğŸ­ é«˜çº§æƒ…æ„Ÿç³»ç»Ÿ</div>
            <label>
                <input type="checkbox" id="advanced_emotion_enabled" checked> å¯ç”¨é«˜çº§æƒ…æ„Ÿç³»ç»Ÿ
            </label>

            <!-- æƒ…æ„Ÿç³»ç»ŸçŠ¶æ€ -->
            <div id="emotion_system_status" style="margin: 10px 0; padding: 8px; border-radius: 4px; font-size: 12px;"></div>

            <!-- å½“å‰æƒ…æ„ŸçŠ¶æ€æ˜¾ç¤º -->
            <div id="current_emotion_display" style="margin: 10px 0; padding: 8px; background: #f5f5f5; border-radius: 4px;">
                <div style="font-weight: bold; margin-bottom: 5px;">å½“å‰æƒ…æ„ŸçŠ¶æ€:</div>
                <div id="emotion_type_display">ä¸­æ€§</div>
                <div id="emotion_intensity_display">å¼ºåº¦: è½»å¾®</div>
                <div id="emotion_transition_display" style="font-size: 11px; color: #666;"></div>
            </div>

            <!-- æ‰‹åŠ¨æƒ…æ„Ÿæ§åˆ¶ -->
            <div style="margin: 10px 0;">
                <label>æ‰‹åŠ¨è®¾ç½®æƒ…æ„Ÿ:</label>
                <select id="manual_emotion_type">
                    <option value="neutral">ä¸­æ€§</option>
                    <option value="happy">å¼€å¿ƒ</option>
                    <option value="sad">æ‚²ä¼¤</option>
                    <option value="angry">ç”Ÿæ°”</option>
                    <option value="surprised">æƒŠè®¶</option>
                    <option value="confused">å›°æƒ‘</option>
                    <option value="shy">å®³ç¾</option>
                    <option value="excited">å…´å¥‹</option>
                    <option value="worried">æ‹…å¿ƒ</option>
                    <option value="loving">å–œçˆ±</option>
                    <option value="thinking">æ€è€ƒ</option>
                    <option value="sleepy">å›°å€¦</option>
                </select>
                <input type="range" id="manual_emotion_intensity" min="0.1" max="1.0" step="0.1" value="0.8">
                <button onclick="setManualEmotion()">è®¾ç½®</button>
            </div>

            <!-- æ‰‹åŠ¿æ§åˆ¶ -->
            <div style="margin: 10px 0;">
                <label>è§¦å‘æ‰‹åŠ¿:</label>
                <select id="gesture_type">
                    <option value="blink">çœ¨çœ¼</option>
                    <option value="nod">ç‚¹å¤´</option>
                    <option value="shake">æ‘‡å¤´</option>
                    <option value="wave">æŒ¥æ‰‹</option>
                    <option value="thinking">æ€è€ƒ</option>
                </select>
                <button onclick="triggerGesture()">è§¦å‘</button>
            </div>

            <!-- è‡ªåŠ¨åŠ¨ç”»æ§åˆ¶ -->
            <div style="margin: 10px 0;">
                <label>
                    <input type="checkbox" id="auto_blink" checked> è‡ªåŠ¨çœ¨çœ¼
                </label>
                <label>
                    <input type="checkbox" id="auto_idle" checked> è‡ªåŠ¨ç©ºé—²åŠ¨ç”»
                </label>
            </div>

            <!-- æƒ…æ„Ÿå†å² -->
            <div style="margin: 10px 0;">
                <button onclick="showEmotionHistory()">æŸ¥çœ‹æƒ…æ„Ÿå†å²</button>
                <button onclick="resetEmotion()">é‡ç½®åˆ°ä¸­æ€§</button>
            </div>

            <!-- æƒ…æ„Ÿå†å²æ˜¾ç¤º -->
            <div id="emotion_history_display" style="max-height: 100px; overflow-y: auto; font-size: 11px; display: none;"></div>
        </div>

        <!-- å¤šæ¨¡æ€AIç³»ç»Ÿ -->
        <div class="section">
            <div class="section-title">ğŸ–¼ï¸ å¤šæ¨¡æ€AIç³»ç»Ÿ</div>
            <label>
                <input type="checkbox" id="multimodal_enabled"> å¯ç”¨å¤šæ¨¡æ€åŠŸèƒ½
            </label>

            <!-- å¤šæ¨¡æ€ç³»ç»ŸçŠ¶æ€ -->
            <div id="multimodal_status" style="margin: 10px 0; padding: 8px; border-radius: 4px; font-size: 12px;"></div>

            <div id="multimodal_controls" style="display: none;">
                <!-- å›¾åƒä¸Šä¼  -->
                <div style="margin: 10px 0;">
                    <label>ä¸Šä¼ å›¾åƒ:</label>
                    <input type="file" id="image_upload" accept="image/*" style="margin: 5px 0;">
                    <button id="upload_image_btn" onclick="uploadImage()">ä¸Šä¼ </button>
                </div>

                <!-- ä¸Šä¼ è¿›åº¦ -->
                <div id="image_upload_progress" style="display: none; margin: 10px 0;">
                    <div style="background: #f0f0f0; border-radius: 4px; overflow: hidden;">
                        <div id="image_progress_bar" style="height: 20px; background: #4CAF50; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div id="image_progress_text" style="font-size: 12px; margin-top: 5px;"></div>
                </div>

                <!-- å›¾åƒåˆ—è¡¨ -->
                <div id="uploaded_images" style="max-height: 200px; overflow-y: auto; margin: 10px 0;"></div>

                <!-- å›¾åƒåˆ†æ -->
                <div style="margin: 10px 0;">
                    <label>é€‰æ‹©å›¾åƒ:</label>
                    <select id="selected_image_id" style="width: 60%;">
                        <option value="">è¯·é€‰æ‹©å›¾åƒ</option>
                    </select>
                    <button onclick="analyzeSelectedImage()" style="width: 35%;">åˆ†æ</button>
                </div>

                <!-- å›¾åƒé—®ç­” -->
                <div style="margin: 10px 0;">
                    <input type="text" id="image_question" placeholder="å¯¹å›¾åƒæé—®..." style="width: 70%;">
                    <button onclick="askImageQuestion()" style="width: 25%;">æé—®</button>
                </div>

                <!-- å¤šæ¨¡æ€æœç´¢ -->
                <div style="margin: 10px 0;">
                    <input type="text" id="multimodal_search_query" placeholder="æœç´¢å›¾åƒå’Œæ–‡æœ¬..." style="width: 50%;">
                    <select id="search_type" style="width: 20%;">
                        <option value="all">å…¨éƒ¨</option>
                        <option value="images">å›¾åƒ</option>
                        <option value="text">æ–‡æœ¬</option>
                    </select>
                    <button onclick="searchMultimodal()" style="width: 25%;">æœç´¢</button>
                </div>

                <!-- æœç´¢ç»“æœ -->
                <div id="multimodal_search_results" style="max-height: 150px; overflow-y: auto; font-size: 11px;"></div>

                <!-- å›¾åƒæ¯”è¾ƒ -->
                <div style="margin: 10px 0;">
                    <label>å›¾åƒæ¯”è¾ƒ:</label>
                    <select id="compare_image1" style="width: 30%;">
                        <option value="">å›¾åƒ1</option>
                    </select>
                    <select id="compare_image2" style="width: 30%;">
                        <option value="">å›¾åƒ2</option>
                    </select>
                    <button onclick="compareImages()" style="width: 35%;">æ¯”è¾ƒ</button>
                </div>

                <!-- æ¯”è¾ƒç»“æœ -->
                <div id="image_comparison_result" style="font-size: 11px; margin: 10px 0;"></div>
            </div>
        </div>

        <!-- è¯­éŸ³æƒ…æ„Ÿç³»ç»Ÿ -->
        <div class="section">
            <div class="section-title">ğŸµ è¯­éŸ³æƒ…æ„Ÿç³»ç»Ÿ</div>
            <label>
                <input type="checkbox" id="voice_emotion_enabled"> å¯ç”¨è¯­éŸ³æƒ…æ„ŸåŠŸèƒ½
            </label>

            <!-- è¯­éŸ³æƒ…æ„Ÿç³»ç»ŸçŠ¶æ€ -->
            <div id="voice_emotion_status" style="margin: 10px 0; padding: 8px; border-radius: 4px; font-size: 12px;"></div>

            <div id="voice_emotion_controls" style="display: none;">
                <!-- è¯­éŸ³é£æ ¼é€‰æ‹© -->
                <div style="margin: 10px 0;">
                    <label>è¯­éŸ³é£æ ¼:</label>
                    <select id="voice_style_select" style="width: 70%;">
                        <option value="default">é»˜è®¤é£æ ¼</option>
                        <option value="gentle">æ¸©æŸ”é£æ ¼</option>
                        <option value="energetic">æ´»åŠ›é£æ ¼</option>
                        <option value="calm">å¹³é™é£æ ¼</option>
                        <option value="cute">å¯çˆ±é£æ ¼</option>
                    </select>
                    <button onclick="setVoiceStyle()" style="width: 25%;">è®¾ç½®</button>
                </div>

                <!-- è¯­éŸ³è§’è‰²é€‰æ‹© -->
                <div style="margin: 10px 0;">
                    <label>è¯­éŸ³è§’è‰²:</label>
                    <select id="voice_character_select" style="width: 50%;">
                        <option value="xiaoxiao">æ™“æ™“(å¥³å£°)</option>
                        <option value="yunxi">äº‘å¸Œ(ç”·å£°)</option>
                        <option value="xiaoyi">æ™“ä¼Š(å¥³å£°)</option>
                        <option value="yunjian">äº‘å¥(ç”·å£°)</option>
                        <option value="xiaomeng">æ™“æ¢¦(å¥³å£°)</option>
                    </select>
                    <select id="voice_language_select" style="width: 30%;">
                        <option value="zh-CN">ä¸­æ–‡</option>
                        <option value="en-US">è‹±æ–‡</option>
                    </select>
                    <button onclick="setVoiceCharacter()" style="width: 15%;">è®¾ç½®</button>
                </div>

                <!-- æƒ…æ„Ÿè®¾ç½® -->
                <div style="margin: 10px 0;">
                    <label>æƒ…æ„Ÿç±»å‹:</label>
                    <select id="emotion_type_select" style="width: 40%;">
                        <option value="neutral">ä¸­æ€§</option>
                        <option value="happy">å¼€å¿ƒ</option>
                        <option value="sad">æ‚²ä¼¤</option>
                        <option value="excited">å…´å¥‹</option>
                        <option value="calm">å¹³é™</option>
                        <option value="angry">ç”Ÿæ°”</option>
                        <option value="surprised">æƒŠè®¶</option>
                        <option value="confused">å›°æƒ‘</option>
                        <option value="shy">å®³ç¾</option>
                        <option value="worried">æ‹…å¿ƒ</option>
                        <option value="loving">å–œçˆ±</option>
                        <option value="thinking">æ€è€ƒ</option>
                        <option value="sleepy">å›°å€¦</option>
                    </select>
                    <label>å¼ºåº¦:</label>
                    <input type="range" id="emotion_intensity" min="0.1" max="1.0" step="0.1" value="1.0" style="width: 30%;">
                    <span id="emotion_intensity_value">1.0</span>
                </div>

                <!-- è¯­éŸ³æµ‹è¯• -->
                <div style="margin: 10px 0;">
                    <input type="text" id="voice_test_text" placeholder="è¾“å…¥æµ‹è¯•æ–‡æœ¬..." style="width: 60%;" value="ä½ å¥½ï¼Œè¿™æ˜¯è¯­éŸ³æµ‹è¯•ã€‚">
                    <button onclick="testVoiceSynthesis()" style="width: 20%;">æµ‹è¯•</button>
                    <button onclick="synthesizeRealtime()" style="width: 15%;">å®æ—¶</button>
                </div>

                <!-- è¯­éŸ³è®¾ç½® -->
                <div style="margin: 10px 0;">
                    <label>
                        <input type="checkbox" id="auto_language_detection"> è‡ªåŠ¨è¯­è¨€æ£€æµ‹
                    </label>
                    <label>
                        <input type="checkbox" id="auto_play_voice"> è‡ªåŠ¨æ’­æ”¾è¯­éŸ³
                    </label>
                    <label>
                        <input type="checkbox" id="realtime_synthesis"> å®æ—¶åˆæˆ
                    </label>
                </div>

                <!-- æƒ…æ„Ÿæ•æ„Ÿåº¦ -->
                <div style="margin: 10px 0;">
                    <label>æƒ…æ„Ÿæ•æ„Ÿåº¦:</label>
                    <input type="range" id="emotion_sensitivity" min="0.1" max="2.0" step="0.1" value="1.0" style="width: 60%;">
                    <span id="emotion_sensitivity_value">1.0</span>
                    <button onclick="setEmotionSensitivity()" style="width: 20%;">è®¾ç½®</button>
                </div>

                <!-- ä»»åŠ¡çŠ¶æ€ -->
                <div id="voice_task_status" style="max-height: 100px; overflow-y: auto; font-size: 11px; margin: 10px 0;"></div>

                <!-- è¯­éŸ³ç»Ÿè®¡ -->
                <div id="voice_statistics" style="font-size: 11px; color: #666; margin: 10px 0;"></div>
            </div>
        </div>

        <!-- é«˜çº§RAGç³»ç»Ÿ -->
        <div class="section">
            <div class="section-title">ğŸ§  é«˜çº§RAGç³»ç»Ÿ</div>
            <label>
                <input type="checkbox" id="advanced_rag_enabled"> å¯ç”¨é«˜çº§RAGåŠŸèƒ½
            </label>

            <!-- é«˜çº§RAGç³»ç»ŸçŠ¶æ€ -->
            <div id="advanced_rag_status" style="margin: 10px 0; padding: 8px; border-radius: 4px; font-size: 12px;"></div>

            <div id="advanced_rag_controls" style="display: none;">
                <!-- æ–‡æ¡£å¤„ç† -->
                <div style="margin: 10px 0;">
                    <label>é«˜çº§æ–‡æ¡£å¤„ç†:</label>
                    <textarea id="advanced_doc_text" placeholder="è¾“å…¥æ–‡æ¡£å†…å®¹..." style="width: 100%; height: 60px;"></textarea>
                    <div style="margin: 5px 0;">
                        <input type="text" id="advanced_doc_id" placeholder="æ–‡æ¡£IDï¼ˆå¯é€‰ï¼‰" style="width: 40%;">
                        <input type="text" id="advanced_image_path" placeholder="å›¾åƒè·¯å¾„ï¼ˆå¯é€‰ï¼‰" style="width: 40%;">
                        <button onclick="processAdvancedDocument()" style="width: 15%;">å¤„ç†</button>
                    </div>
                </div>

                <!-- é«˜çº§æŸ¥è¯¢ -->
                <div style="margin: 10px 0;">
                    <label>é«˜çº§æŸ¥è¯¢:</label>
                    <input type="text" id="advanced_query_text" placeholder="è¾“å…¥æŸ¥è¯¢é—®é¢˜..." style="width: 60%;">
                    <select id="advanced_query_type" style="width: 20%;">
                        <option value="auto">è‡ªåŠ¨</option>
                        <option value="graph">å›¾æŸ¥è¯¢</option>
                        <option value="reasoning">æ¨ç†</option>
                        <option value="fusion">èåˆ</option>
                    </select>
                    <button onclick="executeAdvancedQuery()" style="width: 15%;">æŸ¥è¯¢</button>
                </div>

                <!-- å¤šæ¨¡æ€æ¨ç† -->
                <div style="margin: 10px 0;">
                    <label>å¤šæ¨¡æ€æ¨ç†:</label>
                    <input type="text" id="reasoning_query" placeholder="æ¨ç†é—®é¢˜..." style="width: 50%;">
                    <select id="reasoning_type" style="width: 25%;">
                        <option value="path_based">è·¯å¾„æ¨ç†</option>
                        <option value="subgraph_matching">å­å›¾åŒ¹é…</option>
                        <option value="random_walk">éšæœºæ¸¸èµ°</option>
                    </select>
                    <button onclick="executeMultimodalReasoning()" style="width: 20%;">æ¨ç†</button>
                </div>

                <!-- çŸ¥è¯†å›¾è°±æ“ä½œ -->
                <div style="margin: 10px 0;">
                    <label>çŸ¥è¯†å›¾è°±:</label>
                    <button onclick="buildKnowledgeGraph()" style="width: 20%;">æ„å»ºå›¾è°±</button>
                    <button onclick="getGraphStats()" style="width: 20%;">å›¾è°±ç»Ÿè®¡</button>
                    <button onclick="clearAdvancedCaches()" style="width: 20%;">æ¸…ç†ç¼“å­˜</button>
                    <button onclick="visualizeGraph()" style="width: 20%;">å¯è§†åŒ–</button>
                </div>

                <!-- å‘é‡åŒ–æµ‹è¯• -->
                <div style="margin: 10px 0;">
                    <label>å‘é‡åŒ–æµ‹è¯•:</label>
                    <input type="text" id="vectorize_text" placeholder="æµ‹è¯•æ–‡æœ¬..." style="width: 50%;">
                    <select id="fusion_strategy" style="width: 25%;">
                        <option value="concatenate">æ‹¼æ¥</option>
                        <option value="average">å¹³å‡</option>
                        <option value="weighted">åŠ æƒ</option>
                        <option value="attention">æ³¨æ„åŠ›</option>
                    </select>
                    <button onclick="testVectorization()" style="width: 20%;">å‘é‡åŒ–</button>
                </div>

                <!-- é«˜çº§è®¾ç½® -->
                <div style="margin: 10px 0;">
                    <label>
                        <input type="checkbox" id="include_reasoning"> åŒ…å«æ¨ç†
                    </label>
                    <label>
                        <input type="checkbox" id="enable_fusion"> å¯ç”¨èåˆ
                    </label>
                    <label>
                        <input type="checkbox" id="multimodal_mode"> å¤šæ¨¡æ€æ¨¡å¼
                    </label>
                </div>

                <!-- ç»“æœæ˜¾ç¤º -->
                <div id="advanced_rag_results" style="max-height: 200px; overflow-y: auto; font-size: 11px; margin: 10px 0; border: 1px solid #ddd; padding: 5px;"></div>

                <!-- ç³»ç»Ÿç»Ÿè®¡ -->
                <div id="advanced_rag_statistics" style="font-size: 11px; color: #666; margin: 10px 0;"></div>
            </div>
        </div>

        <!-- RAGçŸ¥è¯†åº“ç®¡ç† -->
        <div class="section">
            <div class="section-title">ğŸ“š çŸ¥è¯†åº“ç®¡ç†</div>
            <label>
                <input type="checkbox" id="rag_enabled"> å¯ç”¨RAGå¢å¼ºå¯¹è¯
            </label>
            <div id="rag_status" style="margin: 10px 0; padding: 8px; border-radius: 4px; font-size: 12px;"></div>

            <div id="rag_controls" style="display: none;">
                <!-- æ–‡æ¡£ä¸Šä¼  -->
                <div style="margin: 10px 0;">
                    <label>ä¸Šä¼ æ–‡æ¡£:</label>
                    <input type="file" id="document_upload" accept=".pdf,.docx,.doc,.txt,.md" style="margin: 5px 0;">
                    <button id="upload_btn" onclick="uploadDocument()">ä¸Šä¼ </button>
                </div>

                <!-- ä¸Šä¼ è¿›åº¦ -->
                <div id="upload_progress" style="display: none; margin: 10px 0;">
                    <div style="background: #f0f0f0; border-radius: 4px; overflow: hidden;">
                        <div id="progress_bar" style="height: 20px; background: #4CAF50; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div id="progress_text" style="font-size: 12px; margin-top: 5px;"></div>
                </div>

                <!-- çŸ¥è¯†åº“ä¿¡æ¯ -->
                <div id="knowledge_base_info" style="margin: 10px 0; font-size: 12px;"></div>

                <!-- æ–‡æ¡£åˆ—è¡¨ -->
                <div id="document_list" style="max-height: 150px; overflow-y: auto; margin: 10px 0;"></div>

                <!-- æœç´¢æµ‹è¯• -->
                <div style="margin: 10px 0;">
                    <input type="text" id="search_query" placeholder="æœç´¢æ–‡æ¡£å†…å®¹..." style="width: 70%;">
                    <button onclick="searchDocuments()" style="width: 25%;">æœç´¢</button>
                </div>
                <div id="search_results" style="max-height: 100px; overflow-y: auto; font-size: 11px;"></div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">èƒŒæ™¯è®¾ç½®</div>

            <div class="tabs">
                <div class="tab active" data-tab="color">çº¯è‰²èƒŒæ™¯</div>
                <div class="tab" data-tab="image">å›¾ç‰‡èƒŒæ™¯</div>
            </div>

            <div class="tab-content active" id="color-tab">
                <div class="bg-option">
                    <label for="bg_color">èƒŒæ™¯é¢œè‰²:</label>
                    <input type="color" id="bg_color" value="#FFFFFF">
                </div>
                <button id="update_bg_color">æ›´æ–°èƒŒæ™¯é¢œè‰²</button>
            </div>

            <div class="tab-content" id="image-tab">
                <select id="bg_image_preset">
                    <option value="">- é€‰æ‹©é¢„è®¾èƒŒæ™¯ -</option>
                    <option value="./backgrounds/classroom.jpg">æ•™å®¤</option>
                    <option value="./backgrounds/beach.jpg">æµ·æ»©</option>
                    <option value="./backgrounds/forest.jpg">æ£®æ—</option>
                    <option value="./backgrounds/space.jpg">å¤ªç©º</option>
                </select>

                <div class="bg-input-group">
                    <label for="bg_image_url">è‡ªå®šä¹‰èƒŒæ™¯å›¾ç‰‡URL:</label>
                    <input type="url" id="bg_image_url" placeholder="è¾“å…¥å›¾ç‰‡URL...">
                </div>
                <button id="update_bg_image">æ›´æ–°èƒŒæ™¯å›¾ç‰‡</button>
            </div>
        </div>
    </div>

    <!-- æ·»åŠ LFSæ£€æŸ¥ç»“æœå¼¹çª— -->
    <div id="lfs_dialog" class="dialog" style="display: none;">
        <div class="dialog-content">
            <span class="close-btn">&times;</span>
            <h3>æ¨¡å‹æ–‡ä»¶æ£€æŸ¥ç»“æœ</h3>
            <div id="lfs_check_result"></div>
            <div class="dialog-actions">
                <button id="close_lfs_dialog">å…³é—­</button>
            </div>
        </div>
    </div>

    <script>
        // Live2D æ¨¡å‹é…ç½®
        const modelPaths = {
            'March 7th': './models/March 7th/March 7th.model3.json',
            'kei_vowels_pro': './models/kei_vowels_pro/kei_vowels_pro.model3.json',
            'Nova - F': './models/Nova - F/Nova - F.model3.json',
            'Hiyori': './models/Hiyori/Hiyori.model3.json',
            'pachan': './models/pachan/pachan.model3.json',
            'EVA RIN normal': './models/EVA RIN normal/EVA RIN normal.model3.json'
        };

        // æ·»åŠ æ¨¡å‹ç±»å‹æ˜ å°„
        const modelTypes = {
            'March 7th': 'cubism4',
            'kei_vowels_pro': 'cubism4',
            'Nova - F': 'cubism4',
            'Hiyori': 'cubism4',
            'pachan': 'cubism4',
            'EVA RIN normal': 'cubism4'
        };

        // æ·»åŠ æƒ…ç»ªå’ŒåŠ¨ä½œç³»ç»Ÿ
        const emotionKeywords = {
            'å¼€å¿ƒ': ['é«˜å…´', 'å¿«ä¹', 'æ¬¢å–œ', 'å–œæ‚¦', 'å…´å¥‹', 'æ„‰å¿«', 'ç¬‘'],
            'æ‚²ä¼¤': ['éš¾è¿‡', 'ä¼¤å¿ƒ', 'å“­', 'å¿§ä¼¤', 'æ‚²ç—›', 'éš¾å—', 'è‹¦æ¼', 'ä¸å¼€å¿ƒ'],
            'æƒŠè®¶': ['éœ‡æƒŠ', 'åƒæƒŠ', 'æƒŠè®¶', 'æ„å¤–', 'æ²¡æƒ³åˆ°', 'ä¸å¯æ€è®®'],
            'ç”Ÿæ°”': ['æ„¤æ€’', 'æ¼ç«', 'ä¸çˆ½', 'è®¨åŒ', 'æ¨', 'çƒ¦èº', 'ä¸æ‚¦'],
            'å®³ç¾': ['ç¾æ¶©', 'å®³ç¾', 'ä¸å¥½æ„æ€', 'è…¼è…†', 'éš¾ä¸ºæƒ…'],
            'ç–‘æƒ‘': ['å›°æƒ‘', 'ç–‘é—®', 'ä¸è§£', 'è¿·æƒ‘', 'ä¸æ˜ç™½', 'ä¸æ‡‚']
        };

        // å¯¹åº”çš„è¡¨æƒ…å’ŒåŠ¨ä½œé…ç½®
        const expressionActions = {
            'å¼€å¿ƒ': {
                parameterIds: ['ParamMouthForm', 'ParamEyeLOpen', 'ParamEyeROpen', 'ParamBrowLY', 'ParamBrowRY'],
                parameterValues: [1, 0.8, 0.8, 0.5, 0.5],
                duration: 8000,  // è¡¨æƒ…æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
                priority: 2      // è¡¨æƒ…ä¼˜å…ˆçº§
            },
            'æ‚²ä¼¤': {
                parameterIds: ['ParamMouthForm', 'ParamEyeLOpen', 'ParamEyeROpen', 'ParamBrowLY', 'ParamBrowRY'],
                parameterValues: [-0.8, 0.5, 0.5, -0.8, -0.8],
                duration: 10000,
                priority: 3
            },
            'æƒŠè®¶': {
                parameterIds: ['ParamMouthOpenY', 'ParamEyeLOpen', 'ParamEyeROpen', 'ParamBrowLY', 'ParamBrowRY'],
                parameterValues: [0.5, 1.2, 1.2, 1, 1],
                duration: 7000,
                priority: 3
            },
            'ç”Ÿæ°”': {
                parameterIds: ['ParamMouthForm', 'ParamEyeLOpen', 'ParamEyeROpen', 'ParamBrowLY', 'ParamBrowRY'],
                parameterValues: [-0.5, 0.8, 0.8, -1, -1],
                duration: 10000,
                priority: 3
            },
            'å®³ç¾': {
                parameterIds: ['ParamMouthForm', 'ParamEyeLOpen', 'ParamEyeROpen', 'ParamBrowLY', 'ParamBrowRY'],
                parameterValues: [0.2, 0.7, 0.7, 0.2, 0.2],
                duration: 8000,
                priority: 2
            },
            'ç–‘æƒ‘': {
                parameterIds: ['ParamMouthForm', 'ParamEyeLOpen', 'ParamEyeROpen', 'ParamBrowLY', 'ParamBrowRY'],
                parameterValues: [0, 0.8, 0.8, -0.5, 0.5],
                duration: 6000,
                priority: 1
            }
        };

        // å£å‹åŒæ­¥å‚æ•°é…ç½®
        const lipSyncParams = {
            // æ§åˆ¶å˜´å·´å¼€åˆçš„å‚æ•°
            mouthOpenY: 'ParamMouthOpenY',  // å˜´å·´å¼€åˆå‚æ•°
            mouthForm: 'ParamMouthForm',    // å˜´å·´å½¢æ€å‚æ•°
            // çœ¨çœ¼ç›¸å…³å‚æ•°
            eyeL: 'ParamEyeLOpen',          // å·¦çœ¼å¼€åˆå‚æ•°
            eyeR: 'ParamEyeROpen',          // å³çœ¼å¼€åˆå‚æ•°
            // åŠ¨ç”»é…ç½®
            blinkInterval: [3000, 7000],    // çœ¨çœ¼é—´éš”èŒƒå›´ï¼ˆæ¯«ç§’ï¼‰
            blinkDuration: 100,             // çœ¨çœ¼æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
            // éŸ³é¢‘åˆ†æé…ç½®
            audioAnalysisInterval: 50,      // éŸ³é¢‘åˆ†æé—´éš”ï¼ˆæ¯«ç§’ï¼‰
            mouthOpenMax: 1.5,              // å˜´å·´æœ€å¤§å¼€åº¦
            mouthOpenMin: 0.0,              // å˜´å·´æœ€å°å¼€åº¦
            volumeThreshold: 0.01           // éŸ³é‡é˜ˆå€¼
        };

        // æ·»åŠ åŠ¨ä½œé…ç½®
        const motionGroups = {
            'æ‰“æ‹›å‘¼': ['motion/tap_head.motion3.json', 'motion/shake_body.motion3.json'],
            'ç‚¹å¤´': ['motion/nod.motion3.json'],
            'æ‘‡å¤´': ['motion/shake_head.motion3.json'],
            'æ€è€ƒ': ['motion/thinking.motion3.json'],
            'è·³èˆ': ['motion/dance.motion3.json']
        };

        let currentModel;
        let app;
        let chatHistory = [];
        let currentAudio = null;
        let lastAudioUrl = null;
        let currentExpression = null;
        let expressionTimeout = null;
        let lipSyncActive = false;
        let lipSyncInterval = null;
        let lastBlinkTime = 0;
        let audioContext = null;
        let audioAnalyser = null;
        let audioDataArray = null;

        // åˆå§‹åŒ–æ¨¡å‹é€‰æ‹©ä¸‹æ‹‰æ¡†
        const $modelSelect = $("#model_list");
        Object.keys(modelPaths).forEach(model => {
            $modelSelect.append($("<option>").attr("value", model).text(model));
        });

        // éŸ³é¢‘æ§åˆ¶å‡½æ•°
        function updateAudioStatus(message) {
            document.getElementById('audio-status').textContent = message;
        }

        function enableAudioControls(enabled = true) {
            document.getElementById('play_audio').disabled = !enabled;
            document.getElementById('stop_audio').disabled = !enabled || !currentAudio;
        }

        function playAudio() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
                stopLipSync();
            }

            if (lastAudioUrl) {
                currentAudio = new Audio(lastAudioUrl);
                currentAudio.volume = parseFloat(document.getElementById('volume').value);

                // å‡†å¤‡éŸ³é¢‘åˆ†æ
                setupAudioAnalysis(currentAudio);

                currentAudio.onplay = () => {
                    enableAudioControls(true);
                    document.getElementById('play_audio').disabled = true;
                    document.getElementById('stop_audio').disabled = false;
                    updateAudioStatus('æ­£åœ¨æ’­æ”¾...');
                    // å¼€å§‹å£å‹åŒæ­¥
                    startLipSync();
                };

                currentAudio.onended = () => {
                    enableAudioControls(true);
                    document.getElementById('stop_audio').disabled = true;
                    updateAudioStatus('æ’­æ”¾å®Œæˆ');
                    // åœæ­¢å£å‹åŒæ­¥
                    stopLipSync();
                };

                currentAudio.onerror = () => {
                    updateAudioStatus('éŸ³é¢‘æ’­æ”¾å¤±è´¥');
                    enableAudioControls(false);
                    stopLipSync();
                };

                currentAudio.play().catch(error => {
                    console.error('æ’­æ”¾éŸ³é¢‘å¤±è´¥:', error);
                    updateAudioStatus('æ’­æ”¾å¤±è´¥: ' + error.message);
                    stopLipSync();
                });
            }
        }

        function stopAudio() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
                document.getElementById('play_audio').disabled = false;
                document.getElementById('stop_audio').disabled = true;
                updateAudioStatus('å·²åœæ­¢æ’­æ”¾');
                // åœæ­¢å£å‹åŒæ­¥
                stopLipSync();
            }
        }

        // æ–°å¢ï¼šéŸ³é¢‘åˆ†æå’Œå£å‹åŒæ­¥åŠŸèƒ½
        function setupAudioAnalysis(audio) {
            try {
                // æ¸…ç†æ—§çš„åˆ†æå™¨
                if (audioAnalyser) {
                    try {
                        audioAnalyser.disconnect();
                    } catch (e) {
                        console.log("æ–­å¼€æ—§åˆ†æå™¨è¿æ¥æ—¶å‡ºé”™:", e);
                    }
                    audioAnalyser = null;
                }

                // ç¡®ä¿AudioContextå·²åˆå§‹åŒ–
                if (!audioContext) {
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        console.log("AudioContextå·²åˆå§‹åŒ–");
                    } catch (error) {
                        console.error("åˆå§‹åŒ–AudioContextå¤±è´¥:", error);
                        return;
                    }
                }

                if (audioContext.state === 'suspended') {
                    audioContext.resume().catch(err => {
                        console.error("æ¢å¤AudioContextå¤±è´¥:", err);
                    });
                }

                if (!audioContext || audioContext.state === 'closed') {
                    console.warn("AudioContextä¸å¯ç”¨ï¼Œæ— æ³•è®¾ç½®éŸ³é¢‘åˆ†æ");
                    return;
                }

                // åˆ›å»ºåª’ä½“å…ƒç´ æºå’Œåˆ†æå™¨
                const source = audioContext.createMediaElementSource(audio);
                audioAnalyser = audioContext.createAnalyser();
                audioAnalyser.fftSize = 256;

                // è¿æ¥éŸ³é¢‘èŠ‚ç‚¹ï¼šæº -> åˆ†æå™¨ -> è¾“å‡º
                source.connect(audioAnalyser);
                audioAnalyser.connect(audioContext.destination);

                // åˆ›å»ºæ•°æ®æ•°ç»„æ¥æ”¶é¢‘åŸŸæ•°æ®
                const bufferLength = audioAnalyser.frequencyBinCount;
                audioDataArray = new Uint8Array(bufferLength);

                console.log("éŸ³é¢‘åˆ†æå™¨å·²è®¾ç½®å®Œæˆ");

            } catch (error) {
                console.error("è®¾ç½®éŸ³é¢‘åˆ†æå¤±è´¥:", error);
                if (error.name === "InvalidAccessError") {
                    console.error("å¯èƒ½æ˜¯é‡å¤è¿æ¥åª’ä½“æºï¼Œå°è¯•ä½¿ç”¨æ–°çš„AudioContext");
                    audioContext = null;
                    audioAnalyser = null;
                    audioDataArray = null;
                    // å»¶è¿Ÿé‡è¯•ä¸€æ¬¡
                    setTimeout(() => setupAudioAnalysis(audio), 100);
                    return;
                }
                audioAnalyser = null;
                audioDataArray = null;
            }
        }

        // å¯åŠ¨å£å‹åŒæ­¥
        function startLipSync() {
            if (lipSyncActive || !currentModel) return;

            // æ£€æŸ¥æ˜¯å¦ç¦ç”¨äº†å£å‹åŒæ­¥
            if (!$('#lipsync_enabled').is(':checked')) {
                return;
            }

            // ç¡®ä¿æœ‰æ•ˆçš„éŸ³é¢‘åˆ†æå™¨
            if (!audioAnalyser || !audioDataArray) {
                console.warn("éŸ³é¢‘åˆ†æå™¨æœªå‡†å¤‡å¥½ï¼Œæ— æ³•å¯åŠ¨å£å‹åŒæ­¥");
                return;
            }

            lipSyncActive = true;
            lastBlinkTime = Date.now();

            console.log("å¼€å§‹å£å‹åŒæ­¥");

            // å¼€å§‹å£å‹åŒæ­¥å®šæ—¶å™¨
            lipSyncInterval = setInterval(() => {
                if (!currentAudio || currentAudio.paused) {
                    resetMouthParameters();
                    return;
                }

                try {
                    // è·å–éŸ³é¢‘æ•°æ®
                    audioAnalyser.getByteFrequencyData(audioDataArray);

                    // è®¡ç®—å¹³å‡éŸ³é‡ (ç®€å•æ–¹æ³•)
                    let sum = 0;
                    for (let i = 0; i < audioDataArray.length; i++) {
                        sum += audioDataArray[i];
                    }
                    const averageVolume = sum / audioDataArray.length / 255; // å½’ä¸€åŒ–åˆ°0-1

                    // æ ¹æ®éŸ³é‡è®¾ç½®å˜´å‹å‚æ•°
                    if (averageVolume > lipSyncParams.volumeThreshold) {
                        const mouthOpen = lipSyncParams.mouthOpenMin +
                                        (averageVolume * (lipSyncParams.mouthOpenMax - lipSyncParams.mouthOpenMin));

                        // è®¾ç½®å˜´å·´å¼€åˆåº¦
                        setMouthParameters(mouthOpen);
                    } else {
                        // éŸ³é‡ä½äºé˜ˆå€¼ï¼Œå…³é—­å˜´å·´
                        resetMouthParameters();
                    }

                    // éšæœºçœ¨çœ¼
                    const now = Date.now();
                    if (now - lastBlinkTime > getRandomInt(lipSyncParams.blinkInterval[0], lipSyncParams.blinkInterval[1])) {
                        blinkEyes();
                        lastBlinkTime = now;
                    }
                } catch (error) {
                    console.error("å£å‹åŒæ­¥æ›´æ–°å¤±è´¥:", error);
                }

            }, lipSyncParams.audioAnalysisInterval);

            console.log("å·²å¯åŠ¨å£å‹åŒæ­¥");
        }

        // åœæ­¢å£å‹åŒæ­¥
        function stopLipSync() {
            if (lipSyncInterval) {
                clearInterval(lipSyncInterval);
                lipSyncInterval = null;
            }

            // é‡ç½®å£å‹å‚æ•°
            resetMouthParameters();
            lipSyncActive = false;
            console.log("å·²åœæ­¢å£å‹åŒæ­¥");
        }

        // è®¾ç½®å˜´å‹å‚æ•°
        function setMouthParameters(openValue) {
            if (!currentModel) return;

            try {
                // è®¾ç½®å˜´å·´å¼€åˆåº¦
                currentModel.internalModel.coreModel.setParameterValueById(
                    lipSyncParams.mouthOpenY,
                    Math.min(Math.max(openValue, 0), lipSyncParams.mouthOpenMax)
                );

                // å¾®è°ƒå˜´å‹å½¢æ€ï¼Œè®©åŠ¨ç”»æ›´è‡ªç„¶
                const formValue = openValue > 0.5 ? -0.2 : 0.1; // å˜´å·´å¤§å¼€æ—¶æ”¶ç´§å˜´è§’
                currentModel.internalModel.coreModel.setParameterValueById(
                    lipSyncParams.mouthForm,
                    formValue
                );
            } catch (error) {
                console.warn("è®¾ç½®å˜´å‹å‚æ•°å¤±è´¥:", error);
            }
        }

        // é‡ç½®å˜´å‹å‚æ•°
        function resetMouthParameters() {
            if (!currentModel) return;

            try {
                // é‡ç½®å˜´å·´å¼€åˆå’Œå½¢æ€
                currentModel.internalModel.coreModel.setParameterValueById(lipSyncParams.mouthOpenY, 0);
                currentModel.internalModel.coreModel.setParameterValueById(lipSyncParams.mouthForm, 0);
            } catch (error) {
                console.warn("é‡ç½®å˜´å‹å‚æ•°å¤±è´¥:", error);
            }
        }

        // çœ¨çœ¼åŠ¨ç”»
        function blinkEyes() {
            if (!currentModel) return;

            try {
                // å¿«é€Ÿé—­çœ¼
                currentModel.internalModel.coreModel.setParameterValueById(lipSyncParams.eyeL, 0);
                currentModel.internalModel.coreModel.setParameterValueById(lipSyncParams.eyeR, 0);

                // æ¢å¤ççœ¼
                setTimeout(() => {
                    currentModel.internalModel.coreModel.setParameterValueById(lipSyncParams.eyeL, 1);
                    currentModel.internalModel.coreModel.setParameterValueById(lipSyncParams.eyeR, 1);
                }, lipSyncParams.blinkDuration);
            } catch (error) {
                console.warn("çœ¨çœ¼åŠ¨ç”»å¤±è´¥:", error);
            }
        }

        // è¾…åŠ©å‡½æ•°ï¼šè·å–æŒ‡å®šèŒƒå›´å†…çš„éšæœºæ•´æ•°
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // èƒŒæ™¯æ§åˆ¶å‡½æ•°
        function updateBackgroundColor(color) {
            document.getElementById('background').style.backgroundColor = color;
            document.getElementById('background').style.backgroundImage = 'none';
        }

        function updateBackgroundImage(url) {
            if (url) {
                document.getElementById('background').style.backgroundImage = `url('${url}')`;
            } else {
                alert('è¯·è¾“å…¥æœ‰æ•ˆçš„å›¾ç‰‡URL');
            }
        }

        // åŠ è½½Live2Dæ¨¡å‹
        async function loadModel(modelName) {
            try {
                console.log("å¼€å§‹æ¸…ç†æ—§æ¨¡å‹èµ„æº...");
                // æ¸…ç†ç°æœ‰æ¨¡å‹çš„çŠ¶æ€
                if (currentModel) {
                    console.log("å‘ç°æ—§æ¨¡å‹ï¼Œæ‰§è¡Œæ¸…ç†æµç¨‹");
                    // åœæ­¢å£å‹åŒæ­¥
                    stopLipSync();

                    // æ¸…ç†è¡¨æƒ…è®¡æ—¶å™¨
                    if (expressionTimeout) {
                        clearTimeout(expressionTimeout);
                        expressionTimeout = null;
                    }

                    // ç§»é™¤æ—§æ¨¡å‹
                    console.log("ä»èˆå°ç§»é™¤æ—§æ¨¡å‹");
                    app.stage.removeChild(currentModel);

                    // å®Œå…¨é”€æ¯æ¨¡å‹å®ä¾‹
                    console.log("é”€æ¯æ—§æ¨¡å‹èµ„æº");
                    if (typeof currentModel.destroy === 'function') {
                        currentModel.destroy({children: true, texture: true, baseTexture: true});
                    }
                    currentModel = null;

                    // å¼ºåˆ¶åƒåœ¾å›æ”¶æç¤º
                    setTimeout(() => {
                        // å¯é€‰ï¼šæ‰‹åŠ¨æ‰§è¡Œä¸€æ¬¡æµè§ˆå™¨åƒåœ¾å›æ”¶
                        if (window.gc) window.gc();
                        console.log("æ—§æ¨¡å‹æ¸…ç†å®Œæˆ");
                    }, 100);
                }

                // åˆå§‹åŒ–PIXIåº”ç”¨æˆ–æ¸…ç†èˆå°
                if (!app) {
                    console.log("åˆ›å»ºPIXIåº”ç”¨");
                    // åˆ›å»ºPIXIåº”ç”¨
                    app = new PIXI.Application({
                        view: document.getElementById("canvas"),
                        autoStart: true,
                        resizeTo: window,
                        transparent: true,
                        backgroundAlpha: 0
                    });
                } else {
                    console.log("æ¸…ç†PIXIèˆå°");
                    // æ¸…ç†èˆå°ï¼Œç§»é™¤æ‰€æœ‰å­å…ƒç´ 
                    while(app.stage.children.length > 0) {
                        const child = app.stage.getChildAt(0);
                        app.stage.removeChild(child);
                        if (typeof child.destroy === 'function') {
                            child.destroy({children: true, texture: true, baseTexture: true});
                        }
                    }
                }

                // ç¡®ä¿èˆå°æ˜¯ç©ºçš„
                console.log("å½“å‰èˆå°å­å…ƒç´ æ•°é‡:", app.stage.children.length);

                // è·å–æ¨¡å‹è·¯å¾„
                const modelPath = modelPaths[modelName];
                console.log("å‡†å¤‡åŠ è½½æ–°æ¨¡å‹:", modelPath);

                // æ£€æŸ¥æ¨¡å‹ç±»å‹
                let modelType = modelTypes[modelName] || 'cubism4';
                const isModelCubism2 = modelPath.endsWith('.model.json');
                const isModelCubism4 = modelPath.endsWith('.model3.json');

                // æ ¹æ®æ–‡ä»¶æ‰©å±•åç¡®å®šå®é™…ç±»å‹
                if (isModelCubism2) modelType = 'cubism2';
                if (isModelCubism4) modelType = 'cubism4';

                console.log("æ¨¡å‹ç±»å‹:", modelType);

                // æ ¹æ®ç±»å‹é€‰æ‹©åŠ è½½æ–¹æ³•
                let model;
                if (modelType === 'cubism2') {
                    // ä½¿ç”¨Cubism 2å¼•æ“åŠ è½½
                    console.log("ä½¿ç”¨Cubism 2å¼•æ“åŠ è½½æ¨¡å‹");

                    // æ£€æŸ¥æ˜¯å¦åŠ è½½äº†Cubism 2å¼•æ“
                    if (typeof Live2D === 'undefined') {
                        throw new Error("Cubism 2å¼•æ“æœªåŠ è½½ï¼Œæ— æ³•åŠ è½½Cubism 2æ¨¡å‹");
                    }

                    // è¿™é‡Œå®ç°Cubism 2æ¨¡å‹åŠ è½½é€»è¾‘
                    // æ³¨æ„ï¼šè¿™éœ€è¦å®Œæ•´çš„Cubism 2åŠ è½½å®ç°
                    alert("Cubism 2æ¨¡å‹åŠ è½½å°šæœªå®Œå…¨å®ç°ï¼Œè¯·ä½¿ç”¨Cubism 4æ¨¡å‹");
                    throw new Error("Cubism 2æ¨¡å‹åŠ è½½å°šæœªå®ç°");
                } else {
                    // ä½¿ç”¨Cubism 4å¼•æ“åŠ è½½
                    console.log("ä½¿ç”¨Cubism 4å¼•æ“åŠ è½½æ¨¡å‹");
                    model = await PIXI.live2d.Live2DModel.from(modelPath);
                }

                console.log("æ¨¡å‹åŠ è½½å®Œæˆï¼Œæ·»åŠ åˆ°èˆå°");
                app.stage.addChild(model);

                // è°ƒæ•´æ¨¡å‹å¤§å°å’Œä½ç½®
                const scale = Math.min(innerWidth / model.width, innerHeight / model.height);
                model.scale.set(scale);
                model.y = innerHeight * 0.1;
                model.x = innerWidth / 2;

                // è®¾ç½®å½“å‰æ¨¡å‹å¼•ç”¨
                currentModel = model;

                // æ·»åŠ äº¤äº’èƒ½åŠ›
                model.on('hit', (hitAreas) => {
                    console.log('Touched area:', hitAreas);
                    if (hitAreas.includes('Head')) {
                        playModelMotion('æ‰“æ‹›å‘¼');
                    } else if (hitAreas.includes('Body')) {
                        playModelMotion('ç‚¹å¤´');
                    }
                });

                // åŠ è½½é»˜è®¤è¡¨æƒ…
                setModelExpression('å¼€å¿ƒ');

                // è®°å½•åŠ è½½æˆåŠŸ
                console.log("æ¨¡å‹åŠ è½½æˆåŠŸ:", modelName);
                return model;
            } catch (error) {
                console.error("åŠ è½½æ¨¡å‹å¤±è´¥:", error);

                // è®°å½•è¯¦ç»†é”™è¯¯ä¿¡æ¯
                if (error.message === "Invalid moc data") {
                    console.error("å¯èƒ½åŸå› ï¼šæ¨¡å‹æ ¼å¼ä¸å¼•æ“ä¸å…¼å®¹ï¼Œæˆ–æ¨¡å‹æ–‡ä»¶æŸå");

                    // å‘é€é”™è¯¯ä¿¡æ¯åˆ°æœåŠ¡å™¨è¿›è¡Œè®°å½•
                    try {
                        await fetch('/api/log_model_error', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                model_path: modelPaths[modelName],
                                error: error.message,
                                stack: error.stack
                            })
                        });
                    } catch (logError) {
                        console.error("æ— æ³•è®°å½•é”™è¯¯:", logError);
                    }

                    // æç¤ºç”¨æˆ·
                    alert(`åŠ è½½æ¨¡å‹å¤±è´¥ï¼šæ¨¡å‹æ ¼å¼å¯èƒ½ä¸å¼•æ“ä¸å…¼å®¹\nè¯·æ£€æŸ¥ ${modelName} æ˜¯å¦ä¸ºCubism 4æ ¼å¼çš„æ¨¡å‹`);
                } else {
                    alert(`åŠ è½½æ¨¡å‹å¤±è´¥ï¼š${error.message}`);
                }
            }
        }

        // æ–°å¢ï¼šè®¾ç½®æ¨¡å‹è¡¨æƒ…
        async function setModelExpression(expressionName) {
            if (!currentModel) return;

            try {
                const config = expressionActions[expressionName];
                if (!config) {
                    console.warn(`æœªæ‰¾åˆ°è¡¨æƒ…é…ç½®: ${expressionName}`);
                    return;
                }

                // æ£€æŸ¥æ˜¯å¦åº”è¯¥è¦†ç›–å½“å‰è¡¨æƒ…
                if (currentExpression) {
                    const currentConfig = expressionActions[currentExpression];
                    if (currentConfig && currentConfig.priority > config.priority) {
                        console.log(`è¡¨æƒ… ${expressionName} ä¼˜å…ˆçº§ä½äºå½“å‰è¡¨æƒ… ${currentExpression}ï¼Œä¸åˆ‡æ¢`);
                        return;
                    }
                }

                // æ¸…é™¤ä¹‹å‰çš„è¡¨æƒ…timeout
                if (expressionTimeout) {
                    clearTimeout(expressionTimeout);
                    expressionTimeout = null;
                }

                console.log(`è®¾ç½®è¡¨æƒ…: ${expressionName}`);

                // ä½¿ç”¨å‚æ•°æ§åˆ¶è®¾ç½®è¡¨æƒ…
                if (config.parameterIds && config.parameterValues) {
                    for (let i = 0; i < config.parameterIds.length; i++) {
                        const paramId = config.parameterIds[i];
                        const paramValue = config.parameterValues[i];

                        try {
                            // ä½¿ç”¨è¡¥é—´åŠ¨ç”»å¹³æ»‘è¿‡æ¸¡
                            const currentValue = currentModel.internalModel.coreModel.getParameterValueById(paramId);
                            animateParameter(paramId, currentValue, paramValue, 300); // 300mså¹³æ»‘è¿‡æ¸¡
                        } catch (paramError) {
                            console.warn(`è®¾ç½®å‚æ•°å¤±è´¥ ${paramId}: ${paramError.message}`);
                            // å°è¯•ç›´æ¥è®¾ç½®
                            try {
                                currentModel.internalModel.coreModel.setParameterValueById(paramId, paramValue);
                            } catch (e) {
                                console.error(`è®¾ç½®å‚æ•°å½»åº•å¤±è´¥ ${paramId}: ${e.message}`);
                            }
                        }
                    }
                }

                currentExpression = expressionName;

                // è®¾ç½®è¡¨æƒ…æŒç»­æ—¶é—´
                const duration = config.duration || 5000;

                // å®šæ—¶æ¢å¤é»˜è®¤è¡¨æƒ…
                expressionTimeout = setTimeout(() => {
                    try {
                        // å¹³æ»‘æ¢å¤é»˜è®¤è¡¨æƒ…å‚æ•°
                        if (config.parameterIds) {
                            for (let i = 0; i < config.parameterIds.length; i++) {
                                const paramId = config.parameterIds[i];
                                const currentValue = currentModel.internalModel.coreModel.getParameterValueById(paramId);
                                animateParameter(paramId, currentValue, 0, 500); // 500mså¹³æ»‘è¿‡æ¸¡åˆ°é»˜è®¤å€¼
                            }
                        }

                        console.log(`è¡¨æƒ… ${expressionName} å·²æ¢å¤é»˜è®¤çŠ¶æ€`);
                        currentExpression = null;
                    } catch (e) {
                        console.warn("æ¢å¤é»˜è®¤è¡¨æƒ…å¤±è´¥:", e);
                    }

                    expressionTimeout = null;
                }, duration);

            } catch (error) {
                console.error(`è®¾ç½®è¡¨æƒ…å¤±è´¥ ${expressionName}:`, error);
            }
        }

        // å‚æ•°åŠ¨ç”»å‡½æ•°ï¼šå¹³æ»‘è¿‡æ¸¡
        function animateParameter(paramId, startValue, targetValue, duration) {
            if (!currentModel) return;

            const startTime = Date.now();
            const animate = () => {
                if (!currentModel) return;

                const now = Date.now();
                const elapsed = now - startTime;

                if (elapsed >= duration) {
                    // åŠ¨ç”»ç»“æŸï¼Œè®¾ç½®æœ€ç»ˆå€¼
                    currentModel.internalModel.coreModel.setParameterValueById(paramId, targetValue);
                    return;
                }

                // è®¡ç®—å½“å‰è¿›åº¦ï¼ˆä½¿ç”¨ç¼“åŠ¨å‡½æ•°ï¼‰
                const progress = elapsed / duration;
                const easedProgress = 0.5 - 0.5 * Math.cos(Math.PI * progress);

                // è®¡ç®—å½“å‰å€¼
                const currentValue = startValue + (targetValue - startValue) * easedProgress;

                // è®¾ç½®å‚æ•°å€¼
                currentModel.internalModel.coreModel.setParameterValueById(paramId, currentValue);

                // ç»§ç»­åŠ¨ç”»
                requestAnimationFrame(animate);
            };

            // å¯åŠ¨åŠ¨ç”»
            animate();
        }

        // æ–°å¢ï¼šæ’­æ”¾æ¨¡å‹åŠ¨ä½œ
        async function playModelMotion(motionType) {
            if (!currentModel) return;

            try {
                const motions = motionGroups[motionType];
                if (!motions || motions.length === 0) {
                    console.warn(`æœªæ‰¾åˆ°åŠ¨ä½œç»„: ${motionType}`);
                    return;
                }

                // éšæœºé€‰æ‹©ä¸€ä¸ªåŠ¨ä½œ
                const randomMotion = motions[Math.floor(Math.random() * motions.length)];
                console.log(`æ’­æ”¾åŠ¨ä½œ: ${motionType} - ${randomMotion}`);

                // å°è¯•æ’­æ”¾åŠ¨ä½œ
                try {
                    await currentModel.motion(motionType, randomMotion);
                } catch (motionError) {
                    console.warn(`æ— æ³•ä½¿ç”¨motionæ–¹æ³•æ’­æ”¾åŠ¨ä½œ: ${motionError.message}`);

                    // å°è¯•é€šè¿‡ç»„åæ’­æ”¾
                    try {
                        await currentModel.motion(motionType);
                    } catch (groupError) {
                        console.error(`é€šè¿‡ç»„åæ’­æ”¾åŠ¨ä½œå¤±è´¥: ${groupError.message}`);
                    }
                }
            } catch (error) {
                console.error(`æ’­æ”¾åŠ¨ä½œå¤±è´¥ ${motionType}:`, error);
            }
        }

        // æ–°å¢ï¼šåˆ†ææ–‡æœ¬æƒ…æ„Ÿå¹¶è§¦å‘è¡¨æƒ…å’ŒåŠ¨ä½œ
        function analyzeEmotionAndPlayAction(text) {
            if (!text || !currentModel) return;

            // å°†æ–‡æœ¬è½¬ä¸ºå°å†™å¹¶å»é™¤æ ‡ç‚¹
            const normalizedText = text.toLowerCase().replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, "");

            // æ£€æµ‹æƒ…æ„Ÿå…³é”®è¯
            let detectedEmotion = null;
            let maxMatches = 0;

            for (const [emotion, keywords] of Object.entries(emotionKeywords)) {
                let matches = 0;
                for (const keyword of keywords) {
                    if (normalizedText.includes(keyword)) {
                        matches++;
                    }
                }

                if (matches > maxMatches) {
                    maxMatches = matches;
                    detectedEmotion = emotion;
                }
            }

            // å¦‚æœæ£€æµ‹åˆ°æƒ…æ„Ÿï¼Œè®¾ç½®è¡¨æƒ…
            if (detectedEmotion && maxMatches > 0) {
                console.log(`æ£€æµ‹åˆ°æƒ…æ„Ÿ: ${detectedEmotion} (åŒ¹é…åº¦: ${maxMatches})`);
                setModelExpression(detectedEmotion);

                // æ ¹æ®æƒ…æ„Ÿé€‰æ‹©åˆé€‚çš„åŠ¨ä½œ
                if (detectedEmotion === 'å¼€å¿ƒ') {
                    playModelMotion('æ‰“æ‹›å‘¼');
                } else if (detectedEmotion === 'æ‚²ä¼¤') {
                    playModelMotion('æ‘‡å¤´');
                } else if (detectedEmotion === 'æƒŠè®¶') {
                    playModelMotion('è·³èˆ');
                } else if (detectedEmotion === 'ç–‘æƒ‘') {
                    playModelMotion('æ€è€ƒ');
                }
            }
        }



        // è¯­éŸ³è¯†åˆ«ç›¸å…³å˜é‡å’Œå‡½æ•°
        let isRecording = false;
        let mediaRecorder = null;
        let audioChunks = [];
        let recognition = null; // Web Speech API

        // åˆå§‹åŒ–æµè§ˆå™¨è¯­éŸ³è¯†åˆ«
        function initBrowserSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.warn('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ« API');
                return false;
            }

            try {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.continuous = false;
                recognition.interimResults = true;

                // è®¾ç½®è¯­è¨€
                recognition.lang = $('#voice_recognition_language').val() === 'zh' ? 'zh-CN' : 'en-US';

                recognition.onstart = function() {
                    console.log('æµè§ˆå™¨è¯­éŸ³è¯†åˆ«å¼€å§‹');
                    $('#voice_input').addClass('recording');
                    $('#voice_status').show();
                    $('.voice-text').text('æ­£åœ¨è†å¬...');

                    // è®¾ç½®æ¨¡å‹è†å¬çŠ¶æ€
                    setModelExpression('ç–‘æƒ‘');
                    playModelMotion('æ€è€ƒ');
                };

                recognition.onresult = function(event) {
                    let interimTranscript = '';
                    let finalTranscript = '';

                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript;
                        } else {
                            interimTranscript += transcript;
                        }
                    }

                    if (interimTranscript) {
                        $('.voice-text').text('è¯†åˆ«ä¸­: ' + interimTranscript);
                    }

                    if (finalTranscript) {
                        $('#user_input').val(finalTranscript);
                        $('.voice-text').text('è¯†åˆ«ç»“æœ: ' + finalTranscript);

                        // å¦‚æœå¯ç”¨äº†è‡ªåŠ¨å‘é€
                        if ($('#auto_send_voice').is(':checked')) {
                            setTimeout(() => {
                                $('#send_message').click();
                            }, 500);
                        }
                    }
                };

                recognition.onerror = function(event) {
                    console.error('è¯­éŸ³è¯†åˆ«é”™è¯¯:', event.error);
                    $('.voice-text').text('è¯†åˆ«é”™è¯¯: ' + event.error);
                    stopRecording();
                };

                recognition.onend = function() {
                    console.log('æµè§ˆå™¨è¯­éŸ³è¯†åˆ«ç»“æŸ');
                    stopRecording();
                };

                return true;
            } catch (e) {
                console.error('åˆå§‹åŒ–æµè§ˆå™¨è¯­éŸ³è¯†åˆ«å¤±è´¥:', e);
                return false;
            }
        }

        // åˆå§‹åŒ–åª’ä½“å½•åˆ¶
        async function initMediaRecorder() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);

                mediaRecorder.ondataavailable = function(event) {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstart = function() {
                    audioChunks = [];
                    console.log('å¼€å§‹å½•éŸ³');
                    $('#voice_input').addClass('recording');
                    $('#voice_status').show();
                    $('.voice-text').text('æ­£åœ¨å½•éŸ³...');

                    // è®¾ç½®æ¨¡å‹è†å¬çŠ¶æ€
                    setModelExpression('ç–‘æƒ‘');
                    playModelMotion('æ€è€ƒ');
                };

                mediaRecorder.onstop = async function() {
                    console.log('å½•éŸ³ç»“æŸ');
                    $('#voice_input').removeClass('recording');
                    $('.voice-text').text('æ­£åœ¨è¯†åˆ«...');

                    // å¦‚æœæ²¡æœ‰å½•åˆ¶åˆ°éŸ³é¢‘æ•°æ®ï¼Œç›´æ¥è¿”å›
                    if (audioChunks.length === 0) {
                        $('#voice_status').hide();
                        return;
                    }

                    // å°†éŸ³é¢‘æ•°æ®åˆå¹¶ä¸ºä¸€ä¸ª Blob
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });

                    // æ ¹æ®è¯†åˆ«æ¨¡å¼é€‰æ‹©ä¸åŒçš„å¤„ç†æ–¹å¼
                    if ($('#voice_recognition_mode').val() === 'server') {
                        // æœåŠ¡å™¨æ¨¡å¼ï¼šå‘é€åˆ°åç«¯è¿›è¡Œè¯†åˆ«
                        await sendAudioToServer(audioBlob);
                    } else {
                        // æµè§ˆå™¨æ¨¡å¼ï¼šä½¿ç”¨ Web Speech API
                        if (recognition) {
                            // å·²ç»åœ¨ä½¿ç”¨ Web Speech API è¿›è¡Œè¯†åˆ«
                            $('#voice_status').hide();
                        } else {
                            $('.voice-text').text('æµè§ˆå™¨æ¨¡å¼ä¸å¯ç”¨ï¼Œå·²åˆ‡æ¢åˆ°æœåŠ¡å™¨æ¨¡å¼');
                            await sendAudioToServer(audioBlob);
                        }
                    }
                };

                return true;
            } catch (e) {
                console.error('åˆå§‹åŒ–åª’ä½“å½•åˆ¶å™¨å¤±è´¥:', e);
                alert('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æƒé™è®¾ç½®ã€‚');
                return false;
            }
        }

        // å‘é€éŸ³é¢‘åˆ°æœåŠ¡å™¨è¿›è¡Œè¯†åˆ«
        async function sendAudioToServer(audioBlob) {
            try {
                $('.voice-text').text('æ­£åœ¨å°†éŸ³é¢‘å‘é€åˆ°æœåŠ¡å™¨...');

                const formData = new FormData();
                formData.append('audio', audioBlob, 'recording.webm');
                formData.append('language', $('#voice_recognition_language').val());

                const response = await fetch('/api/recognize_voice', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`æœåŠ¡å™¨å“åº”é”™è¯¯: ${response.status}`);
                }

                const result = await response.json();

                if (result.success) {
                    $('#user_input').val(result.text);
                    $('.voice-text').text('è¯†åˆ«ç»“æœ: ' + result.text);

                    // å¦‚æœå¯ç”¨äº†è‡ªåŠ¨å‘é€
                    if ($('#auto_send_voice').is(':checked')) {
                        setTimeout(() => {
                            $('#send_message').click();
                        }, 500);
                    }
                } else {
                    $('.voice-text').text('è¯†åˆ«å¤±è´¥: ' + (result.error || 'æœªçŸ¥é”™è¯¯'));
                }

                // 3ç§’åéšè—çŠ¶æ€
                setTimeout(() => {
                    $('#voice_status').hide();
                }, 3000);

            } catch (e) {
                console.error('å‘é€éŸ³é¢‘åˆ°æœåŠ¡å™¨å¤±è´¥:', e);
                $('.voice-text').text('å‘é€å¤±è´¥: ' + e.message);

                // 3ç§’åéšè—çŠ¶æ€
                setTimeout(() => {
                    $('#voice_status').hide();
                }, 3000);
            }
        }

        // å¼€å§‹å½•éŸ³
        async function startRecording() {
            if (isRecording) return;

            // æ£€æŸ¥æ˜¯å¦å¯ç”¨è¯­éŸ³è¯†åˆ«
            if (!$('#voice_recognition_enabled').is(':checked')) {
                alert('è¯­éŸ³è¯†åˆ«å·²ç¦ç”¨ï¼Œè¯·åœ¨è®¾ç½®ä¸­å¯ç”¨ã€‚');
                return;
            }

            isRecording = true;

            // æ ¹æ®è¯†åˆ«æ¨¡å¼é€‰æ‹©ä¸åŒçš„å½•éŸ³æ–¹å¼
            if ($('#voice_recognition_mode').val() === 'browser') {
                // æµè§ˆå™¨æ¨¡å¼ï¼šä½¿ç”¨ Web Speech API
                if (!recognition && !initBrowserSpeechRecognition()) {
                    // å¦‚æœæµè§ˆå™¨ä¸æ”¯æŒï¼Œåˆ‡æ¢åˆ°æœåŠ¡å™¨æ¨¡å¼
                    $('#voice_recognition_mode').val('server');
                    alert('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ« APIï¼Œå·²åˆ‡æ¢åˆ°æœåŠ¡å™¨æ¨¡å¼ã€‚');

                    // åˆå§‹åŒ–åª’ä½“å½•åˆ¶å™¨
                    if (!mediaRecorder && !await initMediaRecorder()) {
                        isRecording = false;
                        return;
                    }

                    // å¼€å§‹å½•éŸ³
                    mediaRecorder.start();
                } else {
                    // è®¾ç½®è¯­è¨€
                    recognition.lang = $('#voice_recognition_language').val() === 'zh' ? 'zh-CN' : 'en-US';
                    recognition.start();
                }
            } else {
                // æœåŠ¡å™¨æ¨¡å¼ï¼šä½¿ç”¨åª’ä½“å½•åˆ¶å™¨
                if (!mediaRecorder && !await initMediaRecorder()) {
                    isRecording = false;
                    return;
                }

                // å¼€å§‹å½•éŸ³
                mediaRecorder.start();
            }
        }

        // åœæ­¢å½•éŸ³
        function stopRecording() {
            if (!isRecording) return;

            isRecording = false;
            $('#voice_input').removeClass('recording');

            if ($('#voice_recognition_mode').val() === 'browser' && recognition) {
                try {
                    recognition.stop();
                } catch (e) {
                    console.warn('åœæ­¢è¯­éŸ³è¯†åˆ«æ—¶å‡ºé”™:', e);
                }
            } else if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            } else {
                $('#voice_status').hide();
            }
        }

        // åˆå§‹åŒ– AudioContext
        function initAudioContext() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                } catch (e) {
                    console.error('åˆå§‹åŒ– AudioContext å¤±è´¥:', e);
                }
            } else if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        // äº‹ä»¶ç›‘å¬å™¨
        $(document).ready(function() {
            // åŠ è½½å¯ç”¨æ¨¡å‹åˆ—è¡¨
            loadAvailableModels();

            // è®¾ç½®æ¨¡å‹æ›´æ–°æŒ‰é’®
            setupModelUpdateButton();

            // è¯­éŸ³è¯†åˆ«æŒ‰é’®äº‹ä»¶
            $('#voice_input').on('click', function() {
                if (isRecording) {
                    stopRecording();
                } else {
                    startRecording();
                }
            });

            // è¯­éŸ³è¯†åˆ«æ¨¡å¼åˆ‡æ¢
            $('#voice_recognition_mode').on('change', function() {
                // å¦‚æœæ­£åœ¨å½•éŸ³ï¼Œåœæ­¢å½•éŸ³
                if (isRecording) {
                    stopRecording();
                }

                // é‡ç½®è¯­éŸ³è¯†åˆ«çŠ¶æ€
                recognition = null;
            });

            // è¯­è¨€åˆ‡æ¢
            $('#voice_recognition_language').on('change', function() {
                // å¦‚æœæ­£åœ¨å½•éŸ³ï¼Œåœæ­¢å½•éŸ³
                if (isRecording) {
                    stopRecording();
                }

                // é‡ç½®è¯­éŸ³è¯†åˆ«çŠ¶æ€
                recognition = null;
            });

            // æ ‡ç­¾åˆ‡æ¢äº‹ä»¶å¢å¼º
            $(".tab").click(function() {
                const tabGroup = $(this).parent();
                const tabId = $(this).data("tab");

                // ç§»é™¤å½“å‰æ ‡ç­¾ç»„ä¸­çš„æ‰€æœ‰æ¿€æ´»æ ‡ç­¾
                tabGroup.find(".tab").removeClass("active");
                $(this).addClass("active");

                // æ‰¾åˆ°ç›¸å…³çš„å†…å®¹å®¹å™¨
                const tabContents = tabGroup.parent().find(".tab-content");
                tabContents.removeClass("active");

                // æ¿€æ´»ç›¸åº”çš„å†…å®¹
                $(`#${tabId}-tab`).addClass("active");
            });

            // éŸ³é‡æ§åˆ¶
            $("#volume").on('input', function() {
                const volume = parseFloat(this.value);
                $("#volume-value").text(Math.round(volume * 100) + '%');
                if (currentAudio) {
                    currentAudio.volume = volume;
                }
            });

            // éŸ³é¢‘æ§åˆ¶æŒ‰é’®
            $("#play_audio").click(function() {
                // å°è¯•åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆéœ€è¦ç”¨æˆ·äº¤äº’ï¼‰
                initAudioContext();
                playAudio();
            });
            $("#stop_audio").click(stopAudio);

            // å‘é€æ¶ˆæ¯æŒ‰é’®
            $("#send_message").click(function() {
                // å°è¯•åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆéœ€è¦ç”¨æˆ·äº¤äº’ï¼‰
                initAudioContext();

                const message = $("#user_input").val().trim();
                if (message) {
                    sendMessage(message);
                    $("#user_input").val('');
                }
            });

            // è¾“å…¥æ¡†å›è½¦å‘é€
            $("#user_input").keypress(function(e) {
                if (e.which === 13) {
                    const message = $(this).val().trim();
                    if (message) {
                        sendMessage(message);
                        $(this).val('');
                    }
                    e.preventDefault();
                }
            });

            // æ ‡ç­¾åˆ‡æ¢
            $(".tab").click(function() {
                $(".tab").removeClass("active");
                $(this).addClass("active");

                const tabId = $(this).data("tab");
                $(".tab-content").removeClass("active");

                if (tabId === "color") {
                    $("#color-tab").addClass("active");
                } else if (tabId === "image") {
                    $("#image-tab").addClass("active");
                }
            });

            // æ›´æ–°èƒŒæ™¯é¢œè‰²
            $("#update_bg_color").click(function() {
                const color = $("#bg_color").val();
                updateBackgroundColor(color);
            });

            // æ›´æ–°èƒŒæ™¯å›¾ç‰‡
            $("#update_bg_image").click(function() {
                const customUrl = $("#bg_image_url").val().trim();
                const presetUrl = $("#bg_image_preset").val();

                const imageUrl = customUrl || presetUrl;
                if (imageUrl) {
                    updateBackgroundImage(imageUrl);
                } else {
                    alert("è¯·é€‰æ‹©é¢„è®¾å›¾ç‰‡æˆ–è¾“å…¥è‡ªå®šä¹‰å›¾ç‰‡URL");
                }
            });

            // é¢„è®¾èƒŒæ™¯é€‰æ‹©å˜åŒ–æ—¶è‡ªåŠ¨æ›´æ–°
            $("#bg_image_preset").change(function() {
                const presetUrl = $(this).val();
                if (presetUrl) {
                    updateBackgroundImage(presetUrl);
                    $("#bg_image_url").val(''); // æ¸…ç©ºè‡ªå®šä¹‰URL
                }
            });

            // çª—å£å¤§å°æ”¹å˜æ—¶è°ƒæ•´æ¨¡å‹å¤§å°
            window.addEventListener('resize', function() {
                if (currentModel) {
                    const scale = Math.min(innerWidth / currentModel.width, innerHeight / currentModel.height);
                    currentModel.scale.set(scale);
                    currentModel.y = innerHeight * 0.1;
                    currentModel.x = innerWidth / 2;
                }
            });

            // ç¡®ä¿éŸ³é¢‘çŠ¶æ€æ˜¾ç¤ºåŒºåŸŸåˆå§‹åŒ–
            updateAudioStatus('ç­‰å¾…ç”Ÿæˆè¯­éŸ³...');

            // åŠ è½½é»˜è®¤æ¨¡å‹
            setTimeout(() => {
                const defaultModel = $("#model_list").val();
                checkAndLoadModel(defaultModel);
            }, 500);

            // åˆå§‹åŒ–AudioContextï¼ˆéœ€è¦ç”¨æˆ·äº¤äº’è§¦å‘ï¼‰
            function initAudioContext() {
                if (!audioContext) {
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        console.log("AudioContextå·²åˆ›å»º");
                    } catch (error) {
                        console.error("åˆ›å»ºAudioContextå¤±è´¥:", error);
                        return false;
                    }
                }

                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log("AudioContextå·²æ¢å¤");
                    }).catch(error => {
                        console.error("æ¢å¤AudioContextå¤±è´¥:", error);
                    });
                }

                return true;
            }

            // å£å‹åŒæ­¥è®¾ç½®
            $('#lipsync_enabled, #mouth_intensity, #blink_frequency').on('change input', function() {
                updateLipSyncSettings();
            });

            // åˆå§‹åŒ–æ›´æ–°ä¸€æ¬¡å£å‹åŒæ­¥è®¾ç½®
            updateLipSyncSettings();
        });

        // åŠ è½½å¯ç”¨æ¨¡å‹åˆ—è¡¨
        async function loadAvailableModels() {
            try {
                const response = await fetch('/get_model_list');
                if (!response.ok) {
                    throw new Error('è·å–æ¨¡å‹åˆ—è¡¨å¤±è´¥');
                }

                const models = await response.json();
                console.log("æœåŠ¡å™¨è¿”å›æ¨¡å‹åˆ—è¡¨:", models);

                // æ›´æ–°æ¨¡å‹é€‰æ‹©ä¸‹æ‹‰æ¡†
                const $modelSelect = $("#model_list");
                $modelSelect.empty();

                models.forEach(model => {
                    modelPaths[model.name] = model.path;
                    modelTypes[model.name] = model.type;
                    $modelSelect.append($("<option>").attr("value", model.name).text(model.name));
                });

                // å¦‚æœæ²¡æœ‰æ¨¡å‹ï¼Œæ˜¾ç¤ºæç¤º
                if (models.length === 0) {
                    alert("æ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„Live2Dæ¨¡å‹ï¼Œè¯·ç¡®ä¿æ¨¡å‹æ–‡ä»¶å¤¹å­˜åœ¨å¹¶åŒ…å«æœ‰æ•ˆæ¨¡å‹");
                } else {
                    // åŠ è½½é»˜è®¤æ¨¡å‹
                    setTimeout(() => {
                        const defaultModel = $modelSelect.val();
                        if (defaultModel) {
                            checkAndLoadModel(defaultModel);
                        }
                    }, 500);
                }
            } catch (error) {
                console.error('åŠ è½½æ¨¡å‹åˆ—è¡¨å¤±è´¥:', error);
                alert('æ— æ³•åŠ è½½æ¨¡å‹åˆ—è¡¨ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨çŠ¶æ€');
            }
        }

        // è®¾ç½®æ¨¡å‹æ›´æ–°æŒ‰é’®äº‹ä»¶
        function setupModelUpdateButton() {
            $("#update_model").click(function() {
                const selectedModel = $("#model_list").val();
                if (selectedModel) {
                    checkAndLoadModel(selectedModel);
                } else {
                    alert("è¯·é€‰æ‹©ä¸€ä¸ªæ¨¡å‹");
                }
            });
        }

        // æ£€æŸ¥å¹¶åŠ è½½æ¨¡å‹
        async function checkAndLoadModel(modelName) {
            try {
                // åœæ­¢å½“å‰å¯èƒ½æ­£åœ¨è¿›è¡Œçš„æ¨¡å‹ç›¸å…³æ´»åŠ¨
                if (currentModel) {
                    stopLipSync();
                    if (expressionTimeout) {
                        clearTimeout(expressionTimeout);
                        expressionTimeout = null;
                    }
                }

                const modelPath = modelPaths[modelName];
                if (!modelPath) {
                    alert(`æ‰¾ä¸åˆ°æ¨¡å‹ ${modelName} çš„è·¯å¾„é…ç½®`);
                    return;
                }

                console.log(`å¼€å§‹éªŒè¯æ¨¡å‹: ${modelName} (${modelPath})`);

                // éªŒè¯æ¨¡å‹æ–‡ä»¶
                try {
                    const verifyResponse = await fetch(`/api/verify_model_files/${modelPath}`);
                    const verifyResult = await verifyResponse.json();

                    console.log("æ¨¡å‹éªŒè¯ç»“æœ:", verifyResult);

                    if (!verifyResult.is_valid) {
                        let missingFiles = verifyResult.missing_files.join("\n- ");
                        alert(`æ¨¡å‹ ${modelName} ç¼ºå°‘å¿…è¦æ–‡ä»¶:\n- ${missingFiles}`);
                        return;
                    }

                    if (verifyResult.model_type === "cubism2" && modelTypes[modelName] === "cubism4") {
                        alert(`è­¦å‘Š: ${modelName} æ˜¯Cubism 2æ ¼å¼ï¼Œä½†å½“å‰é…ç½®ä¸ºä½¿ç”¨Cubism 4å¼•æ“åŠ è½½`);
                    }

                    if (verifyResult.model_type === "cubism4" && modelTypes[modelName] === "cubism2") {
                        alert(`è­¦å‘Š: ${modelName} æ˜¯Cubism 4æ ¼å¼ï¼Œä½†å½“å‰é…ç½®ä¸ºä½¿ç”¨Cubism 2å¼•æ“åŠ è½½`);
                    }

                } catch (verifyError) {
                    console.warn(`éªŒè¯æ¨¡å‹æ–‡ä»¶å¤±è´¥: ${verifyError.message}, å°è¯•ç›´æ¥åŠ è½½æ¨¡å‹`);
                }

                // åŠ è½½æ¨¡å‹ - åªåœ¨è¿™ä¸€ä¸ªåœ°æ–¹è°ƒç”¨loadModel
                console.log(`å¼€å§‹åŠ è½½æ¨¡å‹: ${modelName}`);
                await loadModel(modelName);

            } catch (error) {
                console.error('æ¨¡å‹åŠ è½½è¿‡ç¨‹å¤±è´¥:', error);
                alert(`åŠ è½½æ¨¡å‹ ${modelName} æ—¶å‡ºé”™: ${error.message}`);
            }
        }

        // æ£€æŸ¥LFSæŒ‡é’ˆ
        async function checkLFSPointers() {
            try {
                const response = await fetch('/api/check_lfs_pointers');
                if (!response.ok) {
                    throw new Error('æ£€æŸ¥LFSæŒ‡é’ˆå¤±è´¥');
                }

                const result = await response.json();
                console.log("LFSæ£€æŸ¥ç»“æœ:", result);

                let html = '';

                if (result.lfs_pointers_found) {
                    html += `<div class="alert alert-danger">
                        <p><strong>å‘ç°Git LFSæŒ‡é’ˆæ–‡ä»¶!</strong></p>
                        <p>æ‚¨çš„æ¨¡å‹æ–‡ä»¶æ˜¯Git LFSæŒ‡é’ˆï¼Œè€Œä¸æ˜¯å®é™…çš„æ¨¡å‹æ•°æ®ï¼Œè¿™å°±æ˜¯æ¨¡å‹æ— æ³•åŠ è½½çš„åŸå› ã€‚</p>
                    </div>`;

                    html += `<h4>å—å½±å“çš„æ–‡ä»¶ï¼š</h4><ul>`;
                    result.files.forEach(file => {
                        html += `<li>${file.path} (å½“å‰å¤§å°: ${file.size} å­—èŠ‚, é¢„æœŸå¤§å°: ${file.expected_size})</li>`;
                    });
                    html += `</ul>`;

                    html += `<h4>è§£å†³æ–¹æ¡ˆï¼š</h4>`;

                    if (result.git_lfs_installed) {
                        html += `<p>1. Git LFSå·²å®‰è£…ï¼Œè¯·è¿è¡Œä»¥ä¸‹å‘½ä»¤æ‹‰å–å®é™…çš„æ¨¡å‹æ–‡ä»¶ï¼š</p>
                        <pre>cd ${result.repo_path}
git lfs pull</pre>`;
                    } else {
                        html += `<p>1. æ‚¨éœ€è¦å®‰è£…Git LFSå¹¶æ‹‰å–æ¨¡å‹æ–‡ä»¶ï¼š</p>
                        <pre># ä¸‹è½½å¹¶å®‰è£…Git LFS: https://git-lfs.github.com/
# ç„¶åè¿è¡Œ:
cd ${result.repo_path}
git lfs install
git lfs pull</pre>`;
                    }

                    html += `<p>2. æˆ–è€…ï¼Œæ‚¨å¯ä»¥ä»Live2Då®˜æ–¹ç½‘ç«™ä¸‹è½½ç¤ºä¾‹æ¨¡å‹ï¼š</p>
                    <p><a href="https://www.live2d.com/en/download/sample-data/" target="_blank">https://www.live2d.com/en/download/sample-data/</a></p>`;
                } else {
                    html += `<div class="alert alert-success">
                        <p><strong>æ¨¡å‹æ–‡ä»¶æ£€æŸ¥æ­£å¸¸</strong></p>
                        <p>æœªå‘ç°Git LFSæŒ‡é’ˆé—®é¢˜ã€‚è¯·æ£€æŸ¥å…¶ä»–å¯èƒ½å¯¼è‡´æ¨¡å‹åŠ è½½å¤±è´¥çš„å› ç´ ï¼š</p>
                        <ul>
                            <li>æ¨¡å‹æ ¼å¼ä¸å¼•æ“ç‰ˆæœ¬æ˜¯å¦åŒ¹é… (Cubism 2 vs Cubism 4)</li>
                            <li>æ¨¡å‹æ–‡ä»¶æ˜¯å¦å®Œæ•´ä¸”æœªæŸå</li>
                            <li>æ¨¡å‹é…ç½®æ–‡ä»¶ä¸­çš„è·¯å¾„æ˜¯å¦æ­£ç¡®</li>
                        </ul>
                    </div>`;
                }

                // æ˜¾ç¤ºç»“æœ
                document.getElementById('lfs_check_result').innerHTML = html;
                document.getElementById('lfs_dialog').style.display = 'block';

            } catch (error) {
                console.error('æ£€æŸ¥LFSæŒ‡é’ˆå¤±è´¥:', error);
                alert(`æ£€æŸ¥æ¨¡å‹æ–‡ä»¶å¤±è´¥: ${error.message}`);
            }
        }

        // å¤„ç†å¯¹è¯æ¡†å…³é—­
        document.querySelector('.close-btn').addEventListener('click', function() {
            document.getElementById('lfs_dialog').style.display = 'none';
        });

        document.getElementById('close_lfs_dialog').addEventListener('click', function() {
            document.getElementById('lfs_dialog').style.display = 'none';
        });

        // ç»‘å®šæ£€æŸ¥æŒ‰é’®äº‹ä»¶
        document.getElementById('check_lfs').addEventListener('click', checkLFSPointers);

        // æ›´æ–°å£å‹åŒæ­¥å‚æ•°
        function updateLipSyncSettings() {
            const lipSyncEnabled = $('#lipsync_enabled').is(':checked');
            const mouthIntensity = parseFloat($('#mouth_intensity').val());
            const blinkFrequency = $('#blink_frequency').val();

            // æ›´æ–°å˜´å·´å¼€åˆå¼ºåº¦
            lipSyncParams.mouthOpenMax = mouthIntensity;
            $('#mouth-value').text(mouthIntensity.toFixed(1));

            // æ›´æ–°çœ¨çœ¼é¢‘ç‡
            switch (blinkFrequency) {
                case 'high':
                    lipSyncParams.blinkInterval = [2000, 4000];
                    break;
                case 'medium':
                    lipSyncParams.blinkInterval = [3000, 7000];
                    break;
                case 'low':
                    lipSyncParams.blinkInterval = [6000, 12000];
                    break;
                case 'none':
                    lipSyncParams.blinkInterval = [1000000, 1000001]; // å®é™…ä¸Šç¦ç”¨çœ¨çœ¼
                    break;
            }

            // å¤„ç†å¯ç”¨/ç¦ç”¨çŠ¶æ€
            if (!lipSyncEnabled && lipSyncActive) {
                stopLipSync();
            } else if (lipSyncEnabled && currentAudio && !currentAudio.paused && !lipSyncActive) {
                startLipSync();
            }
        }

        // ======== ä¼šè¯ç®¡ç† ========
        let currentSessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        // ======== RAG åŠŸèƒ½ ========
        let ragEnabled = false;
        let knowledgeBaseInfo = {};

        // åˆå§‹åŒ–RAGåŠŸèƒ½
        function initRAG() {
            checkRAGStatus();

            // ç»‘å®šäº‹ä»¶
            $('#rag_enabled').change(function() {
                ragEnabled = $(this).is(':checked');
                if (ragEnabled) {
                    $('#rag_controls').show();
                    loadKnowledgeBase();
                } else {
                    $('#rag_controls').hide();
                }
            });
        }

        // æ£€æŸ¥RAGçŠ¶æ€
        async function checkRAGStatus() {
            try {
                const response = await fetch('/api/rag/status');
                const data = await response.json();

                if (data.available) {
                    $('#rag_status').html('<span style="color: green;">âœ“ RAGåŠŸèƒ½å¯ç”¨</span>');
                    knowledgeBaseInfo = data.knowledge_base_info || {};
                    updateKnowledgeBaseDisplay();
                } else {
                    $('#rag_status').html('<span style="color: red;">âœ— RAGåŠŸèƒ½ä¸å¯ç”¨</span>');
                    $('#rag_enabled').prop('disabled', true);
                }
            } catch (error) {
                console.error('æ£€æŸ¥RAGçŠ¶æ€å¤±è´¥:', error);
                $('#rag_status').html('<span style="color: red;">âœ— æ— æ³•è¿æ¥RAGæœåŠ¡</span>');
            }
        }

        // ä¸Šä¼ æ–‡æ¡£
        async function uploadDocument() {
            const fileInput = document.getElementById('document_upload');
            const file = fileInput.files[0];

            if (!file) {
                alert('è¯·é€‰æ‹©è¦ä¸Šä¼ çš„æ–‡ä»¶');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);

            // æ˜¾ç¤ºè¿›åº¦
            $('#upload_progress').show();
            $('#progress_bar').css('width', '0%');
            $('#progress_text').text('æ­£åœ¨ä¸Šä¼ ...');

            try {
                const response = await fetch('/api/rag/upload', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (data.success) {
                    $('#progress_bar').css('width', '100%');
                    $('#progress_text').text('ä¸Šä¼ æˆåŠŸï¼');

                    // æ¸…ç©ºæ–‡ä»¶é€‰æ‹©
                    fileInput.value = '';

                    // åˆ·æ–°çŸ¥è¯†åº“ä¿¡æ¯
                    setTimeout(() => {
                        $('#upload_progress').hide();
                        loadKnowledgeBase();
                    }, 1000);

                    alert('æ–‡æ¡£ä¸Šä¼ æˆåŠŸï¼');
                } else {
                    throw new Error(data.error || 'ä¸Šä¼ å¤±è´¥');
                }
            } catch (error) {
                console.error('ä¸Šä¼ æ–‡æ¡£å¤±è´¥:', error);
                $('#progress_text').text('ä¸Šä¼ å¤±è´¥: ' + error.message);
                setTimeout(() => $('#upload_progress').hide(), 3000);
            }
        }

        // åŠ è½½çŸ¥è¯†åº“ä¿¡æ¯
        async function loadKnowledgeBase() {
            try {
                const response = await fetch('/api/rag/knowledge_base');
                const data = await response.json();

                knowledgeBaseInfo = data.knowledge_base || {};
                updateKnowledgeBaseDisplay();
                updateDocumentList(data.uploaded_files || []);

            } catch (error) {
                console.error('åŠ è½½çŸ¥è¯†åº“ä¿¡æ¯å¤±è´¥:', error);
            }
        }

        // æ›´æ–°çŸ¥è¯†åº“æ˜¾ç¤º
        function updateKnowledgeBaseDisplay() {
            const info = knowledgeBaseInfo;
            const infoHtml = `
                <div>ğŸ“Š çŸ¥è¯†åº“ç»Ÿè®¡:</div>
                <div>â€¢ æ–‡æ¡£æ•°é‡: ${info.total_documents || 0}</div>
                <div>â€¢ æ–‡æœ¬å—æ•°: ${info.total_chunks || 0}</div>
                <div>â€¢ æºæ–‡ä»¶: ${(info.source_files || []).length}</div>
            `;
            $('#knowledge_base_info').html(infoHtml);
        }

        // æ›´æ–°æ–‡æ¡£åˆ—è¡¨
        function updateDocumentList(files) {
            let listHtml = '<div style="font-weight: bold; margin-bottom: 5px;">å·²ä¸Šä¼ æ–‡æ¡£:</div>';

            if (files.length === 0) {
                listHtml += '<div style="color: #666;">æš‚æ— æ–‡æ¡£</div>';
            } else {
                files.forEach(file => {
                    listHtml += `
                        <div style="border: 1px solid #ddd; padding: 5px; margin: 3px 0; border-radius: 3px; font-size: 11px;">
                            <div style="font-weight: bold;">${file.original_filename || file.filename}</div>
                            <div>å¤§å°: ${file.file_size_mb}MB | ç±»å‹: ${file.file_type}</div>
                        </div>
                    `;
                });
            }

            $('#document_list').html(listHtml);
        }

        // æ·»åŠ æ¶ˆæ¯åˆ°å¯¹è¯æ¡†
        function appendMessage(sender, message) {
            const timestamp = new Date().toLocaleTimeString();
            const currentText = $('#text_talk').val();
            const newMessage = `[${timestamp}] ${sender}: ${message}\n`;
            $('#text_talk').val(currentText + newMessage);

            // æ»šåŠ¨åˆ°åº•éƒ¨
            const textArea = document.getElementById('text_talk');
            textArea.scrollTop = textArea.scrollHeight;
        }

        // æ›´æ–°æœ€åä¸€æ¡æ¶ˆæ¯
        function updateLastMessage(sender, message) {
            const textArea = $('#text_talk');
            const currentText = textArea.val();
            const lines = currentText.split('\n');

            // æ‰¾åˆ°æœ€åä¸€æ¡æ¥è‡ªæŒ‡å®šå‘é€è€…çš„æ¶ˆæ¯
            let messageUpdated = false;
            for (let i = lines.length - 1; i >= 0; i--) {
                if (lines[i].includes(`] ${sender}: `)) {
                    const timestamp = lines[i].match(/\[(.*?)\]/)?.[1] || new Date().toLocaleTimeString();
                    lines[i] = `[${timestamp}] ${sender}: ${message}`;
                    messageUpdated = true;
                    break;
                }
            }

            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°è¦æ›´æ–°çš„æ¶ˆæ¯ï¼Œæ·»åŠ æ–°æ¶ˆæ¯
            if (!messageUpdated) {
                const timestamp = new Date().toLocaleTimeString();
                lines.push(`[${timestamp}] ${sender}: ${message}`);
            }

            textArea.val(lines.join('\n'));
            textArea.scrollTop(textArea[0].scrollHeight);
        }

        // æœç´¢æ–‡æ¡£
        async function searchDocuments() {
            const query = $('#search_query').val().trim();
            if (!query) {
                alert('è¯·è¾“å…¥æœç´¢å†…å®¹');
                return;
            }

            try {
                const response = await fetch('/api/rag/search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ query: query, k: 3 })
                });

                const data = await response.json();

                let resultsHtml = `<div style="font-weight: bold;">æœç´¢ç»“æœ (${data.count}):</div>`;

                if (data.results && data.results.length > 0) {
                    data.results.forEach((result, index) => {
                        resultsHtml += `
                            <div style="border: 1px solid #ddd; padding: 5px; margin: 3px 0; border-radius: 3px;">
                                <div style="font-weight: bold; font-size: 10px;">æ¥æº: ${result.source}</div>
                                <div style="font-size: 10px;">${result.content.substring(0, 100)}...</div>
                            </div>
                        `;
                    });
                } else {
                    resultsHtml += '<div style="color: #666;">æœªæ‰¾åˆ°ç›¸å…³å†…å®¹</div>';
                }

                $('#search_results').html(resultsHtml);

            } catch (error) {
                console.error('æœç´¢å¤±è´¥:', error);
                $('#search_results').html('<div style="color: red;">æœç´¢å¤±è´¥</div>');
            }
        }

        // ä¿®æ”¹å‘é€æ¶ˆæ¯å‡½æ•°ä»¥æ”¯æŒRAG
        function sendMessage(message) {
            const userInput = message || $('#user_input').val().trim();
            if (!userInput) return;

            const modelName = $('#llm_model').val();
            const temperature = parseFloat($('#temperature').val());
            const topP = parseFloat($('#top_p').val());
            const rolePrompt = $('#role_prompt').val();
            const voiceId = $('#voice_selection').val();

            // ç¦ç”¨å‘é€æŒ‰é’®ï¼Œæ˜¾ç¤ºåŠ è½½çŠ¶æ€
            $('#send_message').prop('disabled', true);

            // æ¸…ç©ºè¾“å…¥æ¡†
            $('#user_input').val('');

            // æ˜¾ç¤ºç”¨æˆ·æ¶ˆæ¯
            appendMessage('ç”¨æˆ·', userInput);

            // è®¾ç½®æ€è€ƒè¡¨æƒ…å’ŒåŠ¨ä½œ
            setModelExpression('ç–‘æƒ‘');
            playModelMotion('æ€è€ƒ');

            // å‡†å¤‡è¯·æ±‚æ•°æ®
            const requestData = {
                session_id: currentSessionId,
                prompt: userInput,
                role_prompt: rolePrompt,
                model_name: modelName,
                temperature: temperature,
                top_p: topP,
                voice_id: voiceId,
                use_rag: ragEnabled
            };

            // é€‰æ‹©APIç«¯ç‚¹
            const endpoint = ragEnabled ? '/rag_generate' : '/generate';

            // å‘é€è¯·æ±‚
            fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestData)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.body.getReader();
            })
            .then(reader => {
                let assistantMessage = '';
                let retrievedDocs = [];
                let messageInitialized = false;

                function readStream() {
                    return reader.read().then(({ done, value }) => {
                        if (done) return;

                        const chunk = new TextDecoder().decode(value);
                        const lines = chunk.split('\n');

                        let streamShouldContinue = true;

                        for (const line of lines) {
                            if (line.trim()) {
                                try {
                                    const data = JSON.parse(line);

                                    if (data.type === 'retrieved_docs') {
                                        // æ˜¾ç¤ºæ£€ç´¢åˆ°çš„æ–‡æ¡£
                                        retrievedDocs = data.docs;
                                        if (retrievedDocs.length > 0) {
                                            let docsHtml = '<div style="background: #f0f8ff; padding: 8px; margin: 5px 0; border-radius: 4px; font-size: 11px;">';
                                            docsHtml += '<strong>ğŸ“š å‚è€ƒæ–‡æ¡£:</strong><br>';
                                            retrievedDocs.forEach(doc => {
                                                docsHtml += `â€¢ ${doc.source}: ${doc.content}<br>`;
                                            });
                                            docsHtml += '</div>';
                                            $('#text_talk').append(docsHtml);
                                            $('#text_talk').scrollTop($('#text_talk')[0].scrollHeight);
                                        }
                                    } else if (data.type === 'emotion_analysis') {
                                        // å¤„ç†æƒ…æ„Ÿåˆ†æç»“æœ
                                        handleEmotionAnalysis(data.emotion_data);
                                    } else if (data.chunk && !data.done) {
                                        assistantMessage += data.chunk;

                                        // åªåœ¨ç¬¬ä¸€æ¬¡æ”¶åˆ°chunkæ—¶åˆ›å»ºæ¶ˆæ¯
                                        if (!messageInitialized) {
                                            appendMessage('AIåŠ©æ‰‹', assistantMessage);
                                            messageInitialized = true;
                                        } else {
                                            updateLastMessage('AIåŠ©æ‰‹', assistantMessage);
                                        }
                                    } else if (data.done === true) {
                                        if (data.audio_url) {
                                            currentAudioUrl = data.audio_url;
                                            lastAudioUrl = data.audio_url;
                                            $('#play_audio').prop('disabled', false);
                                            enableAudioControls(true);
                                            updateAudioStatus('è¯­éŸ³ç”Ÿæˆå®Œæˆ');
                                            playAudio(); // è‡ªåŠ¨æ’­æ”¾
                                        } else {
                                            updateAudioStatus('æœªç”Ÿæˆè¯­éŸ³');
                                        }

                                        // å¤„ç†æƒ…æ„Ÿåˆ†æç»“æœ
                                        if (data.user_emotion) {
                                            handleEmotionAnalysis(data.user_emotion);
                                        }
                                        if (data.ai_emotion) {
                                            handleEmotionAnalysis(data.ai_emotion);
                                        }

                                        // åº”ç”¨Live2Då‚æ•°
                                        if (data.live2d_parameters) {
                                            applyLive2DParameters(data.live2d_parameters);
                                        }

                                        // åˆ†æå“åº”æ–‡æœ¬ï¼Œè®¾ç½®è¡¨æƒ…å’ŒåŠ¨ä½œ
                                        analyzeEmotionAndPlayAction(assistantMessage);

                                        // æ˜¾ç¤ºRAGä½¿ç”¨ä¿¡æ¯
                                        if (data.used_rag && data.retrieved_docs_count > 0) {
                                            const ragInfo = `\n<small style="color: #666;">[ä½¿ç”¨äº† ${data.retrieved_docs_count} ä¸ªæ–‡æ¡£ç‰‡æ®µ]</small>`;
                                            updateLastMessage('AIåŠ©æ‰‹', assistantMessage + ragInfo);
                                        }

                                        // æ¢å¤æŒ‰é’®çŠ¶æ€
                                        $('#send_message').prop('disabled', false);

                                        // åœæ­¢æµå¤„ç†ï¼Œç›´æ¥è¿”å›
                                        return;
                                    }
                                } catch (e) {
                                    console.error('è§£æå“åº”å¤±è´¥:', e);
                                }
                            }
                        }

                        // ç»§ç»­è¯»å–ä¸‹ä¸€ä¸ªchunk
                        if (!done) {
                            return readStream();
                        }
                    });
                }

                // å¼€å§‹è¯»å–æµ
                return readStream();
            })
            .catch(error => {
                console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', error);
                appendMessage('ç³»ç»Ÿ', 'å‘é€æ¶ˆæ¯å¤±è´¥: ' + error.message);

                // æ¢å¤æŒ‰é’®çŠ¶æ€
                $('#send_message').prop('disabled', false);

                // è®¾ç½®æ‚²ä¼¤è¡¨æƒ…
                setModelExpression('æ‚²ä¼¤');
            });
        }

        // ======== é«˜çº§æƒ…æ„Ÿç³»ç»ŸåŠŸèƒ½ ========
        let advancedEmotionEnabled = true;
        let currentEmotionState = {
            emotion_type: 'neutral',
            intensity: 0.1,
            is_transitioning: false
        };

        // åˆå§‹åŒ–é«˜çº§æƒ…æ„Ÿç³»ç»Ÿ
        function initAdvancedEmotionSystem() {
            checkEmotionSystemStatus();

            // ç»‘å®šäº‹ä»¶
            $('#advanced_emotion_enabled').change(function() {
                advancedEmotionEnabled = $(this).is(':checked');
                if (advancedEmotionEnabled) {
                    startEmotionParameterUpdates();
                } else {
                    stopEmotionParameterUpdates();
                }
            });

            // å¯åŠ¨å‚æ•°æ›´æ–°å¾ªç¯
            if (advancedEmotionEnabled) {
                startEmotionParameterUpdates();
            }
        }

        // æ£€æŸ¥æƒ…æ„Ÿç³»ç»ŸçŠ¶æ€
        async function checkEmotionSystemStatus() {
            try {
                const response = await fetch('/api/emotion/status');
                const data = await response.json();

                if (data.available) {
                    $('#emotion_system_status').html('<span style="color: green;">âœ“ é«˜çº§æƒ…æ„Ÿç³»ç»Ÿå¯ç”¨</span>');
                    updateEmotionDisplay(data.status.current_emotion);
                } else {
                    $('#emotion_system_status').html('<span style="color: red;">âœ— é«˜çº§æƒ…æ„Ÿç³»ç»Ÿä¸å¯ç”¨</span>');
                    $('#advanced_emotion_enabled').prop('disabled', true);
                }
            } catch (error) {
                console.error('æ£€æŸ¥æƒ…æ„Ÿç³»ç»ŸçŠ¶æ€å¤±è´¥:', error);
                $('#emotion_system_status').html('<span style="color: red;">âœ— æ— æ³•è¿æ¥æƒ…æ„Ÿç³»ç»Ÿ</span>');
            }
        }

        // æ›´æ–°æƒ…æ„ŸçŠ¶æ€æ˜¾ç¤º
        function updateEmotionDisplay(emotionState) {
            if (!emotionState) return;

            currentEmotionState = emotionState;

            $('#emotion_type_display').text(`${emotionState.emotion_label || emotionState.emotion_type}`);
            $('#emotion_intensity_display').text(`å¼ºåº¦: ${emotionState.intensity_label || 'æœªçŸ¥'} (${(emotionState.intensity * 100).toFixed(0)}%)`);

            if (emotionState.is_transitioning && emotionState.transition_info) {
                const transition = emotionState.transition_info;
                $('#emotion_transition_display').text(`è½¬æ¢ä¸­: ${transition.from_emotion} â†’ ${transition.to_emotion} (${(transition.progress * 100).toFixed(0)}%)`);
            } else {
                $('#emotion_transition_display').text('');
            }
        }

        // æ‰‹åŠ¨è®¾ç½®æƒ…æ„Ÿ
        async function setManualEmotion() {
            if (!advancedEmotionEnabled) return;

            const emotionType = $('#manual_emotion_type').val();
            const intensity = parseFloat($('#manual_emotion_intensity').val());

            try {
                const response = await fetch('/api/emotion/trigger', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        emotion_type: emotionType,
                        intensity: intensity
                    })
                });

                const data = await response.json();

                if (data.success) {
                    updateEmotionDisplay(data.current_state);
                    // åº”ç”¨Live2Då‚æ•°
                    if (data.live2d_parameters) {
                        applyLive2DParameters(data.live2d_parameters);
                    }
                } else {
                    console.error('è®¾ç½®æƒ…æ„Ÿå¤±è´¥:', data.error);
                }

            } catch (error) {
                console.error('è®¾ç½®æƒ…æ„Ÿå¤±è´¥:', error);
            }
        }

        // è§¦å‘æ‰‹åŠ¿
        async function triggerGesture() {
            if (!advancedEmotionEnabled) return;

            const gestureName = $('#gesture_type').val();

            try {
                const response = await fetch('/api/emotion/gesture', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        gesture_name: gestureName
                    })
                });

                const data = await response.json();

                if (data.success) {
                    console.log(`è§¦å‘æ‰‹åŠ¿æˆåŠŸ: ${gestureName}`);
                } else {
                    console.error('è§¦å‘æ‰‹åŠ¿å¤±è´¥:', data.error);
                }

            } catch (error) {
                console.error('è§¦å‘æ‰‹åŠ¿å¤±è´¥:', error);
            }
        }

        // æ˜¾ç¤ºæƒ…æ„Ÿå†å²
        async function showEmotionHistory() {
            try {
                const response = await fetch('/api/emotion/history?limit=10');
                const data = await response.json();

                if (data.success) {
                    let historyHtml = '<div style="font-weight: bold; margin-bottom: 5px;">æƒ…æ„Ÿå†å²:</div>';

                    data.history.forEach(item => {
                        const time = new Date(item.timestamp * 1000).toLocaleTimeString();
                        historyHtml += `
                            <div style="border: 1px solid #ddd; padding: 3px; margin: 2px 0; border-radius: 3px;">
                                <div style="font-size: 10px; color: #666;">${time}</div>
                                <div>${item.emotion_label} - ${(item.intensity * 100).toFixed(0)}%</div>
                            </div>
                        `;
                    });

                    $('#emotion_history_display').html(historyHtml).show();
                } else {
                    console.error('è·å–æƒ…æ„Ÿå†å²å¤±è´¥:', data.error);
                }

            } catch (error) {
                console.error('è·å–æƒ…æ„Ÿå†å²å¤±è´¥:', error);
            }
        }

        // é‡ç½®æƒ…æ„ŸçŠ¶æ€
        async function resetEmotion() {
            try {
                const response = await fetch('/api/emotion/reset', {
                    method: 'POST'
                });

                const data = await response.json();

                if (data.success) {
                    updateEmotionDisplay(data.current_state);
                    console.log('æƒ…æ„ŸçŠ¶æ€å·²é‡ç½®');
                } else {
                    console.error('é‡ç½®æƒ…æ„ŸçŠ¶æ€å¤±è´¥:', data.error);
                }

            } catch (error) {
                console.error('é‡ç½®æƒ…æ„ŸçŠ¶æ€å¤±è´¥:', error);
            }
        }

        // åº”ç”¨Live2Då‚æ•°
        function applyLive2DParameters(parameters) {
            if (!currentModel) return;

            try {
                for (const [paramName, value] of Object.entries(parameters)) {
                    if (currentModel.getParameterIndex && currentModel.setParameterValueByIndex) {
                        const paramIndex = currentModel.getParameterIndex(paramName);
                        if (paramIndex >= 0) {
                            currentModel.setParameterValueByIndex(paramIndex, value);
                        }
                    }
                }
            } catch (error) {
                console.error('åº”ç”¨Live2Då‚æ•°å¤±è´¥:', error);
            }
        }

        // å¯åŠ¨æƒ…æ„Ÿå‚æ•°æ›´æ–°å¾ªç¯
        function startEmotionParameterUpdates() {
            if (window.emotionUpdateInterval) {
                clearInterval(window.emotionUpdateInterval);
            }

            window.emotionUpdateInterval = setInterval(async () => {
                if (!advancedEmotionEnabled) return;

                try {
                    const response = await fetch('/api/emotion/parameters');
                    const data = await response.json();

                    if (data.success) {
                        applyLive2DParameters(data.parameters);
                    }
                } catch (error) {
                    // é™é»˜å¤„ç†é”™è¯¯ï¼Œé¿å…æ§åˆ¶å°åˆ·å±
                }
            }, 1000); // 1 FPSæ›´æ–°é¢‘ç‡ï¼Œå‡å°‘æœåŠ¡å™¨è´Ÿè½½
        }

        // åœæ­¢æƒ…æ„Ÿå‚æ•°æ›´æ–°
        function stopEmotionParameterUpdates() {
            if (window.emotionUpdateInterval) {
                clearInterval(window.emotionUpdateInterval);
                window.emotionUpdateInterval = null;
            }
        }

        // å¤„ç†æƒ…æ„Ÿåˆ†æç»“æœ
        function handleEmotionAnalysis(emotionData) {
            if (!advancedEmotionEnabled || !emotionData) return;

            // æ›´æ–°æƒ…æ„Ÿæ˜¾ç¤º
            if (emotionData.current_state) {
                updateEmotionDisplay(emotionData.current_state);
            }

            // æ˜¾ç¤ºæƒ…æ„Ÿåˆ†æç»“æœ
            if (emotionData.emotion_analysis) {
                const analysis = emotionData.emotion_analysis;
                console.log(`æƒ…æ„Ÿåˆ†æ: ${analysis.emotion_label}, å¼ºåº¦: ${analysis.intensity_label}`);
            }
        }

        // ======== å¤šæ¨¡æ€AIç³»ç»ŸåŠŸèƒ½ ========
        let multimodalEnabled = false;
        let uploadedImages = {};

        // åˆå§‹åŒ–å¤šæ¨¡æ€ç³»ç»Ÿ
        function initMultimodalSystem() {
            checkMultimodalStatus();

            // ç»‘å®šäº‹ä»¶
            $('#multimodal_enabled').change(function() {
                multimodalEnabled = $(this).is(':checked');
                if (multimodalEnabled) {
                    $('#multimodal_controls').show();
                    loadUploadedImages();
                } else {
                    $('#multimodal_controls').hide();
                }
            });
        }

        // æ£€æŸ¥å¤šæ¨¡æ€ç³»ç»ŸçŠ¶æ€
        async function checkMultimodalStatus() {
            try {
                const response = await fetch('/api/multimodal/status');
                const data = await response.json();

                if (data.available) {
                    $('#multimodal_status').html('<span style="color: green;">âœ“ å¤šæ¨¡æ€AIç³»ç»Ÿå¯ç”¨</span>');
                } else {
                    $('#multimodal_status').html('<span style="color: red;">âœ— å¤šæ¨¡æ€AIç³»ç»Ÿä¸å¯ç”¨</span>');
                    $('#multimodal_enabled').prop('disabled', true);
                }
            } catch (error) {
                console.error('æ£€æŸ¥å¤šæ¨¡æ€ç³»ç»ŸçŠ¶æ€å¤±è´¥:', error);
                $('#multimodal_status').html('<span style="color: red;">âœ— æ— æ³•è¿æ¥å¤šæ¨¡æ€ç³»ç»Ÿ</span>');
            }
        }

        // ä¸Šä¼ å›¾åƒ
        async function uploadImage() {
            const fileInput = document.getElementById('image_upload');
            const file = fileInput.files[0];

            if (!file) {
                alert('è¯·é€‰æ‹©è¦ä¸Šä¼ çš„å›¾åƒæ–‡ä»¶');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);
            formData.append('add_to_knowledge_base', 'true');

            // æ˜¾ç¤ºè¿›åº¦
            $('#image_upload_progress').show();
            $('#image_progress_bar').css('width', '0%');
            $('#image_progress_text').text('æ­£åœ¨ä¸Šä¼ ...');

            try {
                const response = await fetch('/api/multimodal/upload', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (data.success) {
                    $('#image_progress_bar').css('width', '100%');
                    $('#image_progress_text').text('ä¸Šä¼ æˆåŠŸï¼');

                    // æ¸…ç©ºæ–‡ä»¶é€‰æ‹©
                    fileInput.value = '';

                    // åˆ·æ–°å›¾åƒåˆ—è¡¨
                    setTimeout(() => {
                        $('#image_upload_progress').hide();
                        loadUploadedImages();
                    }, 1000);

                    alert('å›¾åƒä¸Šä¼ æˆåŠŸï¼');
                } else {
                    throw new Error(data.error || 'ä¸Šä¼ å¤±è´¥');
                }
            } catch (error) {
                console.error('ä¸Šä¼ å›¾åƒå¤±è´¥:', error);
                $('#image_progress_text').text('ä¸Šä¼ å¤±è´¥: ' + error.message);
                setTimeout(() => $('#image_upload_progress').hide(), 3000);
            }
        }

        // åŠ è½½å·²ä¸Šä¼ çš„å›¾åƒ
        async function loadUploadedImages() {
            try {
                const response = await fetch('/api/multimodal/images');
                const data = await response.json();

                if (data.success) {
                    uploadedImages = {};
                    let imagesHtml = '<div style="font-weight: bold; margin-bottom: 5px;">å·²ä¸Šä¼ å›¾åƒ:</div>';

                    if (data.images.length === 0) {
                        imagesHtml += '<div style="color: #666;">æš‚æ— å›¾åƒ</div>';
                    } else {
                        data.images.forEach(image => {
                            uploadedImages[image.image_id] = image;
                            imagesHtml += `
                                <div style="border: 1px solid #ddd; padding: 5px; margin: 3px 0; border-radius: 3px; font-size: 11px;">
                                    <div style="font-weight: bold;">${image.filename}</div>
                                    <div>${image.description.substring(0, 50)}...</div>
                                    <div style="color: #666;">${image.analysis_summary}</div>
                                    <button onclick="deleteImage('${image.image_id}')" style="font-size: 10px; margin-top: 3px;">åˆ é™¤</button>
                                </div>
                            `;
                        });
                    }

                    $('#uploaded_images').html(imagesHtml);
                    updateImageSelectors(data.images);
                }

            } catch (error) {
                console.error('åŠ è½½å›¾åƒåˆ—è¡¨å¤±è´¥:', error);
            }
        }

        // æ›´æ–°å›¾åƒé€‰æ‹©å™¨
        function updateImageSelectors(images) {
            const selectors = ['#selected_image_id', '#compare_image1', '#compare_image2'];

            selectors.forEach(selector => {
                const $select = $(selector);
                $select.empty();
                $select.append('<option value="">è¯·é€‰æ‹©å›¾åƒ</option>');

                images.forEach(image => {
                    $select.append(`<option value="${image.image_id}">${image.filename}</option>`);
                });
            });
        }

        // åˆ†æé€‰ä¸­çš„å›¾åƒ
        async function analyzeSelectedImage() {
            const imageId = $('#selected_image_id').val();
            if (!imageId) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå›¾åƒ');
                return;
            }

            try {
                const response = await fetch('/api/multimodal/analyze', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        image_id: imageId
                    })
                });

                const data = await response.json();

                if (data.success) {
                    const image = uploadedImages[imageId];
                    let analysisHtml = `
                        <div style="border: 1px solid #ddd; padding: 10px; margin: 10px 0; border-radius: 5px;">
                            <h4>${image.filename} åˆ†æç»“æœ</h4>
                            <p><strong>æè¿°:</strong> ${data.description || 'æ— æè¿°'}</p>
                    `;

                    if (data.analysis && data.analysis.success) {
                        const analysis = data.analysis;
                        if (analysis.objects && analysis.objects.length > 0) {
                            analysisHtml += `<p><strong>è¯†åˆ«ç‰©ä½“:</strong> ${analysis.objects.join(', ')}</p>`;
                        }
                        if (analysis.emotions && analysis.emotions.length > 0) {
                            analysisHtml += `<p><strong>æƒ…æ„Ÿ:</strong> ${analysis.emotions.join(', ')}</p>`;
                        }
                        if (analysis.scene) {
                            analysisHtml += `<p><strong>åœºæ™¯:</strong> ${analysis.scene}</p>`;
                        }
                    }

                    analysisHtml += '</div>';

                    // æ˜¾ç¤ºåœ¨å¯¹è¯æ¡†ä¸­
                    appendMessage('ç³»ç»Ÿ', analysisHtml);
                } else {
                    alert('å›¾åƒåˆ†æå¤±è´¥: ' + data.error);
                }

            } catch (error) {
                console.error('å›¾åƒåˆ†æå¤±è´¥:', error);
                alert('å›¾åƒåˆ†æå¤±è´¥');
            }
        }

        // å¯¹å›¾åƒæé—®
        async function askImageQuestion() {
            const imageId = $('#selected_image_id').val();
            const question = $('#image_question').val().trim();

            if (!imageId) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå›¾åƒ');
                return;
            }

            if (!question) {
                alert('è¯·è¾“å…¥é—®é¢˜');
                return;
            }

            try {
                const response = await fetch('/api/multimodal/analyze', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        image_id: imageId,
                        question: question
                    })
                });

                const data = await response.json();

                if (data.success) {
                    const image = uploadedImages[imageId];
                    const questionHtml = `
                        <div style="border: 1px solid #ddd; padding: 10px; margin: 10px 0; border-radius: 5px;">
                            <h4>å›¾åƒé—®ç­”</h4>
                            <p><strong>å›¾åƒ:</strong> ${image.filename}</p>
                            <p><strong>é—®é¢˜:</strong> ${question}</p>
                            <p><strong>å›ç­”:</strong> ${data.answer}</p>
                        </div>
                    `;

                    // æ˜¾ç¤ºåœ¨å¯¹è¯æ¡†ä¸­
                    appendMessage('ç³»ç»Ÿ', questionHtml);

                    // æ¸…ç©ºé—®é¢˜è¾“å…¥
                    $('#image_question').val('');
                } else {
                    alert('å›¾åƒé—®ç­”å¤±è´¥: ' + data.error);
                }

            } catch (error) {
                console.error('å›¾åƒé—®ç­”å¤±è´¥:', error);
                alert('å›¾åƒé—®ç­”å¤±è´¥');
            }
        }

        // å¤šæ¨¡æ€æœç´¢
        async function searchMultimodal() {
            const query = $('#multimodal_search_query').val().trim();
            const searchType = $('#search_type').val();

            if (!query) {
                alert('è¯·è¾“å…¥æœç´¢å†…å®¹');
                return;
            }

            try {
                const response = await fetch('/api/multimodal/search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        query: query,
                        search_type: searchType
                    })
                });

                const data = await response.json();

                if (data.success) {
                    let resultsHtml = `<div style="font-weight: bold; margin-bottom: 5px;">æœç´¢ç»“æœ (${data.result_count}æ¡):</div>`;

                    if (data.results.length === 0) {
                        resultsHtml += '<div style="color: #666;">æœªæ‰¾åˆ°ç›¸å…³å†…å®¹</div>';
                    } else {
                        data.results.forEach((result, index) => {
                            const typeLabel = result.type === 'image' ? 'å›¾åƒ' : result.type === 'image_text' ? 'å›¾æ–‡' : 'æ–‡æœ¬';
                            resultsHtml += `
                                <div style="border: 1px solid #ddd; padding: 5px; margin: 3px 0; border-radius: 3px;">
                                    <div style="font-weight: bold; color: #333;">[${typeLabel}] ${result.metadata.filename || 'æœªçŸ¥æ–‡ä»¶'}</div>
                                    <div style="font-size: 10px;">${result.content.substring(0, 100)}...</div>
                                    <div style="font-size: 9px; color: #666;">ç›¸å…³åº¦: ${(result.relevance_score * 100).toFixed(0)}%</div>
                                </div>
                            `;
                        });
                    }

                    $('#multimodal_search_results').html(resultsHtml);

                    // æ˜¾ç¤ºAIå›ç­”
                    if (data.response) {
                        const responseHtml = `
                            <div style="border: 1px solid #ddd; padding: 10px; margin: 10px 0; border-radius: 5px;">
                                <h4>å¤šæ¨¡æ€æœç´¢å›ç­”</h4>
                                <p><strong>é—®é¢˜:</strong> ${query}</p>
                                <p><strong>å›ç­”:</strong> ${data.response}</p>
                            </div>
                        `;
                        appendMessage('ç³»ç»Ÿ', responseHtml);
                    }
                } else {
                    alert('æœç´¢å¤±è´¥: ' + data.error);
                }

            } catch (error) {
                console.error('å¤šæ¨¡æ€æœç´¢å¤±è´¥:', error);
                alert('æœç´¢å¤±è´¥');
            }
        }

        // æ¯”è¾ƒå›¾åƒ
        async function compareImages() {
            const imageId1 = $('#compare_image1').val();
            const imageId2 = $('#compare_image2').val();

            if (!imageId1 || !imageId2) {
                alert('è¯·é€‰æ‹©ä¸¤ä¸ªè¦æ¯”è¾ƒçš„å›¾åƒ');
                return;
            }

            if (imageId1 === imageId2) {
                alert('è¯·é€‰æ‹©ä¸åŒçš„å›¾åƒè¿›è¡Œæ¯”è¾ƒ');
                return;
            }

            try {
                const response = await fetch('/api/multimodal/compare', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        image_id1: imageId1,
                        image_id2: imageId2,
                        comparison_aspect: 'æ•´ä½“ç›¸ä¼¼æ€§'
                    })
                });

                const data = await response.json();

                if (data.success) {
                    const image1 = uploadedImages[imageId1];
                    const image2 = uploadedImages[imageId2];
                    const similarity = (data.overall_similarity * 100).toFixed(1);

                    let comparisonHtml = `
                        <div style="border: 1px solid #ddd; padding: 8px; margin: 5px 0; border-radius: 4px;">
                            <div style="font-weight: bold;">å›¾åƒæ¯”è¾ƒç»“æœ</div>
                            <div style="font-size: 11px;">
                                <div>å›¾åƒ1: ${image1.filename}</div>
                                <div>å›¾åƒ2: ${image2.filename}</div>
                                <div style="color: #333; margin-top: 5px;">
                                    ç›¸ä¼¼åº¦: <span style="font-weight: bold; color: ${similarity > 70 ? 'green' : similarity > 40 ? 'orange' : 'red'};">${similarity}%</span>
                                </div>
                    `;

                    if (data.vlm_comparison && data.vlm_comparison.comparison_result) {
                        comparisonHtml += `<div style="margin-top: 5px;">åˆ†æ: ${data.vlm_comparison.comparison_result}</div>`;
                    }

                    comparisonHtml += '</div></div>';

                    $('#image_comparison_result').html(comparisonHtml);
                } else {
                    alert('å›¾åƒæ¯”è¾ƒå¤±è´¥: ' + data.error);
                }

            } catch (error) {
                console.error('å›¾åƒæ¯”è¾ƒå¤±è´¥:', error);
                alert('å›¾åƒæ¯”è¾ƒå¤±è´¥');
            }
        }

        // åˆ é™¤å›¾åƒ
        async function deleteImage(imageId) {
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™å¼ å›¾åƒå—ï¼Ÿ')) {
                return;
            }

            try {
                const response = await fetch(`/api/multimodal/images/${imageId}`, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (data.success) {
                    alert('å›¾åƒåˆ é™¤æˆåŠŸ');
                    loadUploadedImages();
                } else {
                    alert('åˆ é™¤å¤±è´¥: ' + data.error);
                }

            } catch (error) {
                console.error('åˆ é™¤å›¾åƒå¤±è´¥:', error);
                alert('åˆ é™¤å¤±è´¥');
            }
        }

        // ======== è¯­éŸ³æƒ…æ„Ÿç³»ç»ŸåŠŸèƒ½ ========
        let voiceEmotionEnabled = false;
        let voiceTasks = {};

        // åˆå§‹åŒ–è¯­éŸ³æƒ…æ„Ÿç³»ç»Ÿ
        function initVoiceEmotionSystem() {
            checkVoiceEmotionStatus();

            // ç»‘å®šäº‹ä»¶
            $('#voice_emotion_enabled').change(function() {
                voiceEmotionEnabled = $(this).is(':checked');
                if (voiceEmotionEnabled) {
                    $('#voice_emotion_controls').show();
                    loadVoiceSettings();
                } else {
                    $('#voice_emotion_controls').hide();
                }
            });

            // ç»‘å®šæ»‘å—äº‹ä»¶
            $('#emotion_intensity').on('input', function() {
                $('#emotion_intensity_value').text($(this).val());
            });

            $('#emotion_sensitivity').on('input', function() {
                $('#emotion_sensitivity_value').text($(this).val());
            });
        }

        // æ£€æŸ¥è¯­éŸ³æƒ…æ„Ÿç³»ç»ŸçŠ¶æ€
        async function checkVoiceEmotionStatus() {
            try {
                const response = await fetch('/api/voice/status');
                const data = await response.json();

                if (data.available) {
                    $('#voice_emotion_status').html('<span style="color: green;">âœ“ è¯­éŸ³æƒ…æ„Ÿç³»ç»Ÿå¯ç”¨</span>');
                    updateVoiceStatistics(data.status);
                } else {
                    $('#voice_emotion_status').html('<span style="color: red;">âœ— è¯­éŸ³æƒ…æ„Ÿç³»ç»Ÿä¸å¯ç”¨</span>');
                    $('#voice_emotion_enabled').prop('disabled', true);
                }
            } catch (error) {
                console.error('æ£€æŸ¥è¯­éŸ³æƒ…æ„Ÿç³»ç»ŸçŠ¶æ€å¤±è´¥:', error);
                $('#voice_emotion_status').html('<span style="color: red;">âœ— æ— æ³•è¿æ¥è¯­éŸ³æƒ…æ„Ÿç³»ç»Ÿ</span>');
            }
        }

        // åŠ è½½è¯­éŸ³è®¾ç½®
        async function loadVoiceSettings() {
            try {
                // åŠ è½½å¯ç”¨è¯­éŸ³
                const voicesResponse = await fetch('/api/voice/voices');
                const voicesData = await voicesResponse.json();

                // åŠ è½½å¯ç”¨é£æ ¼
                const stylesResponse = await fetch('/api/voice/styles');
                const stylesData = await stylesResponse.json();

                // æ›´æ–°ç•Œé¢
                updateVoiceSelectors(voicesData, stylesData);

            } catch (error) {
                console.error('åŠ è½½è¯­éŸ³è®¾ç½®å¤±è´¥:', error);
            }
        }

        // æ›´æ–°è¯­éŸ³é€‰æ‹©å™¨
        function updateVoiceSelectors(voicesData, stylesData) {
            // æ›´æ–°é£æ ¼é€‰æ‹©å™¨
            const $styleSelect = $('#voice_style_select');
            $styleSelect.empty();

            if (stylesData.styles) {
                Object.keys(stylesData.styles).forEach(styleName => {
                    const style = stylesData.styles[styleName];
                    $styleSelect.append(`<option value="${styleName}">${style.name}</option>`);
                });
            }

            // è®¾ç½®å½“å‰é£æ ¼
            if (stylesData.current_style) {
                $styleSelect.val(stylesData.current_style);
            }
        }

        // è®¾ç½®è¯­éŸ³é£æ ¼
        async function setVoiceStyle() {
            const styleName = $('#voice_style_select').val();

            try {
                const response = await fetch('/api/voice/style', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        style_name: styleName
                    })
                });

                const data = await response.json();

                if (data.success) {
                    showMessage('è¯­éŸ³é£æ ¼è®¾ç½®æˆåŠŸ: ' + data.description, 'success');
                } else {
                    showMessage('è¯­éŸ³é£æ ¼è®¾ç½®å¤±è´¥: ' + data.error, 'error');
                }

            } catch (error) {
                console.error('è®¾ç½®è¯­éŸ³é£æ ¼å¤±è´¥:', error);
                showMessage('è®¾ç½®è¯­éŸ³é£æ ¼å¤±è´¥', 'error');
            }
        }

        // è®¾ç½®è¯­éŸ³è§’è‰²
        async function setVoiceCharacter() {
            const voiceName = $('#voice_character_select').val();
            const language = $('#voice_language_select').val();

            try {
                const response = await fetch('/api/voice/settings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        voice_name: voiceName,
                        language: language
                    })
                });

                const data = await response.json();

                if (data.success) {
                    showMessage('è¯­éŸ³è§’è‰²è®¾ç½®æˆåŠŸ', 'success');
                } else {
                    showMessage('è¯­éŸ³è§’è‰²è®¾ç½®å¤±è´¥: ' + data.error, 'error');
                }

            } catch (error) {
                console.error('è®¾ç½®è¯­éŸ³è§’è‰²å¤±è´¥:', error);
                showMessage('è®¾ç½®è¯­éŸ³è§’è‰²å¤±è´¥', 'error');
            }
        }

        // è®¾ç½®æƒ…æ„Ÿæ•æ„Ÿåº¦
        async function setEmotionSensitivity() {
            const sensitivity = parseFloat($('#emotion_sensitivity').val());

            try {
                const response = await fetch('/api/voice/settings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        emotion_sensitivity: sensitivity
                    })
                });

                const data = await response.json();

                if (data.success) {
                    showMessage('æƒ…æ„Ÿæ•æ„Ÿåº¦è®¾ç½®æˆåŠŸ', 'success');
                } else {
                    showMessage('æƒ…æ„Ÿæ•æ„Ÿåº¦è®¾ç½®å¤±è´¥: ' + data.error, 'error');
                }

            } catch (error) {
                console.error('è®¾ç½®æƒ…æ„Ÿæ•æ„Ÿåº¦å¤±è´¥:', error);
                showMessage('è®¾ç½®æƒ…æ„Ÿæ•æ„Ÿåº¦å¤±è´¥', 'error');
            }
        }

        // æµ‹è¯•è¯­éŸ³åˆæˆ
        async function testVoiceSynthesis() {
            const text = $('#voice_test_text').val().trim();
            const emotion = $('#emotion_type_select').val();
            const intensity = parseFloat($('#emotion_intensity').val());

            if (!text) {
                showMessage('è¯·è¾“å…¥æµ‹è¯•æ–‡æœ¬', 'warning');
                return;
            }

            try {
                showMessage('æ­£åœ¨åˆæˆè¯­éŸ³...', 'info');

                const response = await fetch('/api/voice/synthesize', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: text,
                        emotion: emotion,
                        intensity: intensity,
                        realtime: false,
                        auto_play: $('#auto_play_voice').is(':checked')
                    })
                });

                const data = await response.json();

                if (data.success) {
                    showMessage('è¯­éŸ³åˆæˆæˆåŠŸ', 'success');

                    // æ˜¾ç¤ºåˆæˆä¿¡æ¯
                    const infoHtml = `
                        <div style="border: 1px solid #ddd; padding: 8px; margin: 5px 0; border-radius: 4px; font-size: 11px;">
                            <div><strong>è¯­éŸ³åˆæˆå®Œæˆ</strong></div>
                            <div>æƒ…æ„Ÿ: ${data.emotion} (å¼ºåº¦: ${data.intensity})</div>
                            <div>è¯­éŸ³: ${data.voice_name} (${data.language})</div>
                            <div>æ—¶é•¿: ${data.duration ? data.duration.toFixed(1) + 's' : 'æœªçŸ¥'}</div>
                        </div>
                    `;

                    $('#voice_task_status').prepend(infoHtml);
                } else {
                    showMessage('è¯­éŸ³åˆæˆå¤±è´¥: ' + data.error, 'error');
                }

            } catch (error) {
                console.error('è¯­éŸ³åˆæˆæµ‹è¯•å¤±è´¥:', error);
                showMessage('è¯­éŸ³åˆæˆæµ‹è¯•å¤±è´¥', 'error');
            }
        }

        // å®æ—¶è¯­éŸ³åˆæˆ
        async function synthesizeRealtime() {
            const text = $('#voice_test_text').val().trim();
            const emotion = $('#emotion_type_select').val();
            const intensity = parseFloat($('#emotion_intensity').val());

            if (!text) {
                showMessage('è¯·è¾“å…¥æµ‹è¯•æ–‡æœ¬', 'warning');
                return;
            }

            try {
                const response = await fetch('/api/voice/synthesize', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: text,
                        emotion: emotion,
                        intensity: intensity,
                        realtime: true,
                        auto_play: $('#auto_play_voice').is(':checked')
                    })
                });

                const data = await response.json();

                if (data.success) {
                    showMessage('å®æ—¶åˆæˆä»»åŠ¡å·²æäº¤', 'success');

                    // æ·»åŠ ä»»åŠ¡åˆ°ç›‘æ§åˆ—è¡¨
                    voiceTasks[data.task_id] = {
                        text: text,
                        emotion: emotion,
                        intensity: intensity,
                        status: 'pending',
                        created_at: new Date()
                    };

                    // å¼€å§‹ç›‘æ§ä»»åŠ¡
                    monitorVoiceTask(data.task_id);

                    // æ›´æ–°ä»»åŠ¡æ˜¾ç¤º
                    updateVoiceTaskDisplay();
                } else {
                    showMessage('å®æ—¶åˆæˆå¤±è´¥: ' + data.error, 'error');
                }

            } catch (error) {
                console.error('å®æ—¶è¯­éŸ³åˆæˆå¤±è´¥:', error);
                showMessage('å®æ—¶è¯­éŸ³åˆæˆå¤±è´¥', 'error');
            }
        }

        // ç›‘æ§è¯­éŸ³ä»»åŠ¡
        async function monitorVoiceTask(taskId) {
            const maxAttempts = 30; // æœ€å¤šç›‘æ§30æ¬¡
            let attempts = 0;

            const checkTask = async () => {
                try {
                    const response = await fetch(`/api/voice/task/${taskId}`);
                    const data = await response.json();

                    if (voiceTasks[taskId]) {
                        voiceTasks[taskId].status = data.status;

                        if (data.status === 'completed') {
                            voiceTasks[taskId].result = data.result;
                            showMessage('è¯­éŸ³åˆæˆå®Œæˆ', 'success');
                            updateVoiceTaskDisplay();
                            return;
                        } else if (data.status === 'failed') {
                            voiceTasks[taskId].error = data.error;
                            showMessage('è¯­éŸ³åˆæˆå¤±è´¥: ' + data.error, 'error');
                            updateVoiceTaskDisplay();
                            return;
                        }
                    }

                    attempts++;
                    if (attempts < maxAttempts && data.status === 'processing') {
                        setTimeout(checkTask, 1000); // 1ç§’åå†æ¬¡æ£€æŸ¥
                    } else if (attempts >= maxAttempts) {
                        showMessage('ä»»åŠ¡ç›‘æ§è¶…æ—¶', 'warning');
                    }

                    updateVoiceTaskDisplay();

                } catch (error) {
                    console.error('ç›‘æ§ä»»åŠ¡å¤±è´¥:', error);
                }
            };

            checkTask();
        }

        // æ›´æ–°ä»»åŠ¡æ˜¾ç¤º
        function updateVoiceTaskDisplay() {
            let tasksHtml = '<div style="font-weight: bold; margin-bottom: 5px;">è¯­éŸ³ä»»åŠ¡çŠ¶æ€:</div>';

            const taskIds = Object.keys(voiceTasks).slice(-5); // åªæ˜¾ç¤ºæœ€è¿‘5ä¸ªä»»åŠ¡

            if (taskIds.length === 0) {
                tasksHtml += '<div style="color: #666;">æš‚æ— ä»»åŠ¡</div>';
            } else {
                taskIds.forEach(taskId => {
                    const task = voiceTasks[taskId];
                    const statusColor = {
                        'pending': '#orange',
                        'processing': '#blue',
                        'completed': '#green',
                        'failed': '#red',
                        'cancelled': '#gray'
                    }[task.status] || '#black';

                    tasksHtml += `
                        <div style="border: 1px solid #ddd; padding: 3px; margin: 2px 0; border-radius: 3px;">
                            <div style="font-size: 10px;">
                                <span style="color: ${statusColor};">â—</span> ${task.text.substring(0, 20)}...
                                <span style="float: right;">${task.status}</span>
                            </div>
                        </div>
                    `;
                });
            }

            $('#voice_task_status').html(tasksHtml);
        }

        // æ›´æ–°è¯­éŸ³ç»Ÿè®¡ä¿¡æ¯
        function updateVoiceStatistics(status) {
            if (!status) return;

            let statsHtml = '<div style="font-weight: bold;">ç³»ç»Ÿç»Ÿè®¡:</div>';

            if (status.synthesizer_stats) {
                const stats = status.synthesizer_stats;
                statsHtml += `
                    <div>ç¼“å­˜: ${stats.cache_size} é¡¹</div>
                    <div>å½“å‰è¯­éŸ³: ${stats.current_voice}</div>
                    <div>å½“å‰æƒ…æ„Ÿ: ${stats.current_emotion}</div>
                `;
            }

            if (status.realtime_processor) {
                const processor = status.realtime_processor;
                statsHtml += `
                    <div>é˜Ÿåˆ—ä»»åŠ¡: ${processor.pending_tasks}</div>
                    <div>å¤„ç†ä¸­: ${processor.processing_tasks}</div>
                    <div>å·²å®Œæˆ: ${processor.completed_tasks}</div>
                `;
            }

            $('#voice_statistics').html(statsHtml);
        }

        // æ˜¾ç¤ºæ¶ˆæ¯æç¤º
        function showMessage(message, type = 'info') {
            const colors = {
                'success': '#4CAF50',
                'error': '#f44336',
                'warning': '#ff9800',
                'info': '#2196F3'
            };

            const messageHtml = `
                <div style="background: ${colors[type]}; color: white; padding: 8px; margin: 5px 0; border-radius: 4px; font-size: 12px;">
                    ${message}
                </div>
            `;

            // æ·»åŠ åˆ°å¯¹è¯æ¡†
            appendMessage('ç³»ç»Ÿ', messageHtml);
        }

        // ======== é«˜çº§RAGç³»ç»ŸåŠŸèƒ½ ========
        let advancedRAGEnabled = false;

        // åˆå§‹åŒ–é«˜çº§RAGç³»ç»Ÿ
        function initAdvancedRAGSystem() {
            checkAdvancedRAGStatus();

            // ç»‘å®šäº‹ä»¶
            $('#advanced_rag_enabled').change(function() {
                advancedRAGEnabled = $(this).is(':checked');
                if (advancedRAGEnabled) {
                    $('#advanced_rag_controls').show();
                    loadAdvancedRAGSettings();
                } else {
                    $('#advanced_rag_controls').hide();
                }
            });
        }

        // æ£€æŸ¥é«˜çº§RAGç³»ç»ŸçŠ¶æ€
        async function checkAdvancedRAGStatus() {
            try {
                const response = await fetch('/api/advanced-rag/status');
                const data = await response.json();

                if (data.available) {
                    $('#advanced_rag_status').html('<span style="color: green;">âœ“ é«˜çº§RAGç³»ç»Ÿå¯ç”¨</span>');
                    updateAdvancedRAGStatistics(data.status);
                } else {
                    $('#advanced_rag_status').html('<span style="color: red;">âœ— é«˜çº§RAGç³»ç»Ÿä¸å¯ç”¨</span>');
                    $('#advanced_rag_enabled').prop('disabled', true);
                }
            } catch (error) {
                console.error('æ£€æŸ¥é«˜çº§RAGç³»ç»ŸçŠ¶æ€å¤±è´¥:', error);
                $('#advanced_rag_status').html('<span style="color: red;">âœ— æ— æ³•è¿æ¥é«˜çº§RAGç³»ç»Ÿ</span>');
            }
        }

        // åŠ è½½é«˜çº§RAGè®¾ç½®
        async function loadAdvancedRAGSettings() {
            try {
                // è®¾ç½®é»˜è®¤å€¼
                $('#include_reasoning').prop('checked', true);
                $('#enable_fusion').prop('checked', true);
                $('#multimodal_mode').prop('checked', false);

            } catch (error) {
                console.error('åŠ è½½é«˜çº§RAGè®¾ç½®å¤±è´¥:', error);
            }
        }

        // å¤„ç†é«˜çº§æ–‡æ¡£
        async function processAdvancedDocument() {
            const text = $('#advanced_doc_text').val().trim();
            const docId = $('#advanced_doc_id').val().trim();
            const imagePath = $('#advanced_image_path').val().trim();

            if (!text) {
                showAdvancedRAGMessage('è¯·è¾“å…¥æ–‡æ¡£å†…å®¹', 'warning');
                return;
            }

            try {
                showAdvancedRAGMessage('æ­£åœ¨å¤„ç†æ–‡æ¡£...', 'info');

                const response = await fetch('/api/advanced-rag/process-document', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: text,
                        doc_id: docId || undefined,
                        image_path: imagePath || undefined,
                        metadata: {
                            processed_at: new Date().toISOString(),
                            source: 'web_interface'
                        }
                    })
                });

                const data = await response.json();

                if (data.success) {
                    showAdvancedRAGMessage('æ–‡æ¡£å¤„ç†æˆåŠŸ', 'success');
                    displayAdvancedRAGResult('æ–‡æ¡£å¤„ç†', data);

                    // æ¸…ç©ºè¾“å…¥
                    $('#advanced_doc_text').val('');
                    $('#advanced_doc_id').val('');
                    $('#advanced_image_path').val('');
                } else {
                    showAdvancedRAGMessage('æ–‡æ¡£å¤„ç†å¤±è´¥: ' + data.error, 'error');
                }

            } catch (error) {
                console.error('æ–‡æ¡£å¤„ç†å¤±è´¥:', error);
                showAdvancedRAGMessage('æ–‡æ¡£å¤„ç†å¤±è´¥', 'error');
            }
        }

        // æ‰§è¡Œé«˜çº§æŸ¥è¯¢
        async function executeAdvancedQuery() {
            const query = $('#advanced_query_text').val().trim();
            const queryType = $('#advanced_query_type').val();
            const includeReasoning = $('#include_reasoning').is(':checked');

            if (!query) {
                showAdvancedRAGMessage('è¯·è¾“å…¥æŸ¥è¯¢é—®é¢˜', 'warning');
                return;
            }

            try {
                showAdvancedRAGMessage('æ­£åœ¨æ‰§è¡Œé«˜çº§æŸ¥è¯¢...', 'info');

                const response = await fetch('/api/advanced-rag/query', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        query: query,
                        query_type: queryType,
                        max_results: 10,
                        include_reasoning: includeReasoning
                    })
                });

                const data = await response.json();

                if (data.success) {
                    showAdvancedRAGMessage('æŸ¥è¯¢æ‰§è¡ŒæˆåŠŸ', 'success');
                    displayAdvancedRAGResult('é«˜çº§æŸ¥è¯¢', data);

                    // æ˜¾ç¤ºèåˆç­”æ¡ˆ
                    if (data.fused_answer) {
                        appendMessage('AIåŠ©æ‰‹', data.fused_answer);
                    }
                } else {
                    showAdvancedRAGMessage('æŸ¥è¯¢æ‰§è¡Œå¤±è´¥: ' + data.error, 'error');
                }

            } catch (error) {
                console.error('é«˜çº§æŸ¥è¯¢å¤±è´¥:', error);
                showAdvancedRAGMessage('é«˜çº§æŸ¥è¯¢å¤±è´¥', 'error');
            }
        }

        // æ‰§è¡Œå¤šæ¨¡æ€æ¨ç†
        async function executeMultimodalReasoning() {
            const query = $('#reasoning_query').val().trim();
            const reasoningType = $('#reasoning_type').val();
            const imagePath = $('#advanced_image_path').val().trim();

            if (!query) {
                showAdvancedRAGMessage('è¯·è¾“å…¥æ¨ç†é—®é¢˜', 'warning');
                return;
            }

            try {
                showAdvancedRAGMessage('æ­£åœ¨æ‰§è¡Œå¤šæ¨¡æ€æ¨ç†...', 'info');

                const response = await fetch('/api/advanced-rag/reasoning', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        query: query,
                        reasoning_type: reasoningType,
                        image_path: imagePath || undefined
                    })
                });

                const data = await response.json();

                if (data.success) {
                    showAdvancedRAGMessage('æ¨ç†æ‰§è¡ŒæˆåŠŸ', 'success');
                    displayAdvancedRAGResult('å¤šæ¨¡æ€æ¨ç†', data);

                    // æ˜¾ç¤ºæ¨ç†ç»“æœ
                    if (data.reasoning_result && data.reasoning_result.answer) {
                        appendMessage('AIæ¨ç†', data.reasoning_result.answer);
                    }
                } else {
                    showAdvancedRAGMessage('æ¨ç†æ‰§è¡Œå¤±è´¥: ' + data.error, 'error');
                }

            } catch (error) {
                console.error('å¤šæ¨¡æ€æ¨ç†å¤±è´¥:', error);
                showAdvancedRAGMessage('å¤šæ¨¡æ€æ¨ç†å¤±è´¥', 'error');
            }
        }

        // æ„å»ºçŸ¥è¯†å›¾è°±
        async function buildKnowledgeGraph() {
            const text = $('#advanced_doc_text').val().trim();
            const docId = $('#advanced_doc_id').val().trim();

            if (!text) {
                showAdvancedRAGMessage('è¯·è¾“å…¥æ–‡æ¡£å†…å®¹æ¥æ„å»ºå›¾è°±', 'warning');
                return;
            }

            try {
                showAdvancedRAGMessage('æ­£åœ¨æ„å»ºçŸ¥è¯†å›¾è°±...', 'info');

                const response = await fetch('/api/advanced-rag/build-graph', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: text,
                        doc_id: docId || undefined
                    })
                });

                const data = await response.json();

                if (data.success) {
                    showAdvancedRAGMessage('çŸ¥è¯†å›¾è°±æ„å»ºæˆåŠŸ', 'success');
                    displayAdvancedRAGResult('çŸ¥è¯†å›¾è°±æ„å»º', data);
                } else {
                    showAdvancedRAGMessage('çŸ¥è¯†å›¾è°±æ„å»ºå¤±è´¥: ' + data.error, 'error');
                }

            } catch (error) {
                console.error('çŸ¥è¯†å›¾è°±æ„å»ºå¤±è´¥:', error);
                showAdvancedRAGMessage('çŸ¥è¯†å›¾è°±æ„å»ºå¤±è´¥', 'error');
            }
        }

        // è·å–å›¾è°±ç»Ÿè®¡
        async function getGraphStats() {
            try {
                const response = await fetch('/api/advanced-rag/graph-stats');
                const data = await response.json();

                showAdvancedRAGMessage('å›¾è°±ç»Ÿè®¡è·å–æˆåŠŸ', 'success');
                displayAdvancedRAGResult('å›¾è°±ç»Ÿè®¡', data);

            } catch (error) {
                console.error('è·å–å›¾è°±ç»Ÿè®¡å¤±è´¥:', error);
                showAdvancedRAGMessage('è·å–å›¾è°±ç»Ÿè®¡å¤±è´¥', 'error');
            }
        }

        // æ¸…ç†é«˜çº§ç¼“å­˜
        async function clearAdvancedCaches() {
            try {
                const response = await fetch('/api/advanced-rag/clear-caches', {
                    method: 'POST'
                });

                const data = await response.json();

                if (data.success) {
                    showAdvancedRAGMessage('ç¼“å­˜æ¸…ç†æˆåŠŸ', 'success');
                } else {
                    showAdvancedRAGMessage('ç¼“å­˜æ¸…ç†å¤±è´¥: ' + data.error, 'error');
                }

            } catch (error) {
                console.error('ç¼“å­˜æ¸…ç†å¤±è´¥:', error);
                showAdvancedRAGMessage('ç¼“å­˜æ¸…ç†å¤±è´¥', 'error');
            }
        }

        // å¯è§†åŒ–å›¾è°±
        function visualizeGraph() {
            showAdvancedRAGMessage('å›¾è°±å¯è§†åŒ–åŠŸèƒ½å¼€å‘ä¸­...', 'info');
            // è¿™é‡Œå¯ä»¥é›†æˆå›¾è°±å¯è§†åŒ–åº“ï¼Œå¦‚D3.jsã€vis.jsç­‰
        }

        // æµ‹è¯•å‘é‡åŒ–
        async function testVectorization() {
            const text = $('#vectorize_text').val().trim();
            const fusionStrategy = $('#fusion_strategy').val();
            const imagePath = $('#advanced_image_path').val().trim();

            if (!text) {
                showAdvancedRAGMessage('è¯·è¾“å…¥æµ‹è¯•æ–‡æœ¬', 'warning');
                return;
            }

            try {
                showAdvancedRAGMessage('æ­£åœ¨æ‰§è¡Œå‘é‡åŒ–...', 'info');

                const response = await fetch('/api/advanced-rag/vectorize', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: text,
                        image_path: imagePath || undefined,
                        fusion_strategy: fusionStrategy
                    })
                });

                const data = await response.json();

                if (data.success) {
                    showAdvancedRAGMessage('å‘é‡åŒ–æˆåŠŸ', 'success');

                    // æ˜¾ç¤ºå‘é‡åŒ–ç»“æœï¼ˆä¸æ˜¾ç¤ºå®Œæ•´å‘é‡ï¼Œåªæ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯ï¼‰
                    const resultInfo = {
                        vector_type: data.vector_type,
                        dimension: data.dimension,
                        fusion_strategy: data.fusion_strategy,
                        vector_preview: data.embedding.slice(0, 5).map(x => x.toFixed(4))
                    };

                    displayAdvancedRAGResult('å‘é‡åŒ–æµ‹è¯•', resultInfo);
                } else {
                    showAdvancedRAGMessage('å‘é‡åŒ–å¤±è´¥: ' + data.error, 'error');
                }

            } catch (error) {
                console.error('å‘é‡åŒ–æµ‹è¯•å¤±è´¥:', error);
                showAdvancedRAGMessage('å‘é‡åŒ–æµ‹è¯•å¤±è´¥', 'error');
            }
        }

        // æ˜¾ç¤ºé«˜çº§RAGæ¶ˆæ¯
        function showAdvancedRAGMessage(message, type = 'info') {
            const colors = {
                'success': '#4CAF50',
                'error': '#f44336',
                'warning': '#ff9800',
                'info': '#2196F3'
            };

            const messageHtml = `
                <div style="background: ${colors[type]}; color: white; padding: 6px; margin: 3px 0; border-radius: 3px; font-size: 11px;">
                    ${message}
                </div>
            `;

            $('#advanced_rag_results').prepend(messageHtml);

            // é™åˆ¶æ¶ˆæ¯æ•°é‡
            const messages = $('#advanced_rag_results').children();
            if (messages.length > 10) {
                messages.slice(10).remove();
            }
        }

        // æ˜¾ç¤ºé«˜çº§RAGç»“æœ
        function displayAdvancedRAGResult(operation, data) {
            const resultHtml = `
                <div style="border: 1px solid #ddd; padding: 6px; margin: 5px 0; border-radius: 3px; font-size: 10px; background: #f9f9f9;">
                    <div style="font-weight: bold; color: #333;">${operation} ç»“æœ:</div>
                    <pre style="margin: 3px 0; white-space: pre-wrap; max-height: 100px; overflow-y: auto;">${JSON.stringify(data, null, 2)}</pre>
                </div>
            `;

            $('#advanced_rag_results').prepend(resultHtml);

            // é™åˆ¶ç»“æœæ•°é‡
            const results = $('#advanced_rag_results').children();
            if (results.length > 5) {
                results.slice(5).remove();
            }
        }

        // æ›´æ–°é«˜çº§RAGç»Ÿè®¡ä¿¡æ¯
        function updateAdvancedRAGStatistics(status) {
            if (!status) return;

            let statsHtml = '<div style="font-weight: bold;">é«˜çº§RAGç»Ÿè®¡:</div>';

            if (status.processing_stats) {
                const stats = status.processing_stats;
                statsHtml += `
                    <div>æ–‡æ¡£å¤„ç†: ${stats.documents_processed}</div>
                    <div>æŸ¥è¯¢å¤„ç†: ${stats.queries_processed}</div>
                    <div>æ¨ç†è¯·æ±‚: ${stats.reasoning_requests}</div>
                    <div>èåˆæ“ä½œ: ${stats.fusion_operations}</div>
                `;
            }

            if (status.knowledge_graph_stats) {
                const kgStats = status.knowledge_graph_stats;
                statsHtml += `
                    <div>å›¾è°±èŠ‚ç‚¹: ${kgStats.nodes}</div>
                    <div>å›¾è°±è¾¹: ${kgStats.edges}</div>
                `;
            }

            if (status.integration_status) {
                const integration = status.integration_status;
                statsHtml += `
                    <div>åŸºç¡€RAG: ${integration.basic_rag_available ? 'âœ“' : 'âœ—'}</div>
                    <div>å¤šæ¨¡æ€: ${integration.multimodal_available ? 'âœ“' : 'âœ—'}</div>
                `;
            }

            $('#advanced_rag_statistics').html(statsHtml);
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        $(document).ready(function() {
            initRAG();
            initAdvancedEmotionSystem();
            initMultimodalSystem();
            initVoiceEmotionSystem();
            initAdvancedRAGSystem();
        });
    </script>
</body>
</html>
