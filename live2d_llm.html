<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live2D AI 助手</title>
    <script src="./js/live2dcubismcore.min.js"></script>
    <script src="./js/live2d.min.js"></script>
    <script src="./js/pixi.min.js"></script>
    <script src="./js/cubism4.min.js"></script>
    <script src="./js/jquery-3.1.1.min.js"></script>
    <style>
        body, html { 
            margin: 0; 
            padding: 0; 
            height: 100%; 
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }
        #background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background-color: #FFFFFF;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            transition: background-color 0.5s, background-image 0.5s;
        }
        #control {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-height: 90vh;
            overflow-y: auto;
            width: 320px;
            z-index: 1000;
        }
        .section {
            border-bottom: 1px solid #eee;
            padding: 10px 0;
            margin-bottom: 10px;
        }
        .section-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        #control label, #control input, #control select, #control button {
            margin: 5px 0;
            display: block;
        }
        #control input[type="text"], 
        #control input[type="url"], 
        #control input[type="search"], 
        #control select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        #control button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }
        #control button:hover {
            background: #45a049;
        }
        #control button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        #text_talk {
            width: 100%;
            height: 150px;
            margin-top: 10px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            font-family: inherit;
        }
        .model-config {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 8px;
            align-items: center;
        }
        .chat-input {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        .chat-input input {
            flex: 1;
        }
        .audio-controls {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        .tts-settings {
            margin-top: 10px;
        }
        .volume-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }
        #audio-status {
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
        }
        .loading {
            color: #666;
            font-style: italic;
        }
        .bg-option {
            margin-top: 10px;
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .bg-input-group {
            margin-top: 10px;
        }
        #bg_type {
            margin-bottom: 10px;
        }
        .tabs {
            display: flex;
            margin-bottom: 10px;
        }
        .tab {
            padding: 5px 10px;
            cursor: pointer;
            border: 1px solid #ddd;
            border-radius: 4px 4px 0 0;
            background: #f5f5f5;
        }
        .tab.active {
            background: #fff;
            border-bottom: 1px solid #fff;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        #bg_image_preset {
            width: 100%;
            margin-bottom: 10px;
        }
        .dialog {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .dialog-content {
            background-color: white;
            margin: 10% auto;
            padding: 20px;
            border-radius: 8px;
            max-width: 600px;
            max-height: 70vh;
            overflow-y: auto;
        }
        
        .close-btn {
            float: right;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.2em;
        }
        
        .alert {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        
        .alert-danger {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        
        .alert-success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        
        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        
        .secondary-button {
            background-color: #6c757d;
            color: white;
        }
        
        .dialog-actions {
            margin-top: 15px;
            text-align: right;
        }
        
        /* 新增：口型同步控制样式 */
        .lipsync-settings {
            margin-top: 5px;
        }
        
        .control-group {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-group label {
            flex: 0 0 120px;
        }
        
        .control-group input[type="range"] {
            flex: 1;
        }
        
        .control-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin: 0;
            display: inline-block;
        }
        
        #mouth-value {
            min-width: 30px;
            text-align: right;
        }
        
        /* 美化范围滑块 */
        input[type="range"] {
            height: 8px;
            border-radius: 4px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>
    <div id="background"></div>
    <canvas id="canvas"></canvas>

    <div id="control">
        <div class="section">
            <div class="section-title">模型控制</div>
            <div class="model-selection">
                <label for="model_list">选择模型:</label>
                <select id="model_list">
                    <option value="March 7th">March 7th</option>
                    <option value="kei_vowels_pro">kei_vowels_pro</option>
                    <option value="Nova - F">Nova - F</option>
                    <option value="Hiyori">Hiyori</option>
                    <option value="pachan">pachan</option>
                    <option value="EVA RIN normal">EVA RIN normal</option>
                </select>
                <button id="update_model">更新模型</button>
                <button id="check_lfs" class="secondary-button">检查模型文件</button>
            </div>
        </div>

        <div class="section">
            <div class="section-title">语音设置</div>
            <div class="tts-settings">
                <select id="voice_selection">
                    <option value="21m00Tcm4TlvDq8ikWAM">chinese (中文)</option>
                    <option value="AZnzlk1XvdvUeBnXmlld">Endlish (英语)</option>
                </select>
                <div class="volume-control">
                    <label for="volume">音量:</label>
                    <input type="range" id="volume" min="0" max="1" step="0.1" value="0.7">
                    <span id="volume-value">70%</span>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">口型同步设置</div>
            <div class="lipsync-settings">
                <div class="control-group">
                    <label for="lipsync_enabled">启用口型同步:</label>
                    <input type="checkbox" id="lipsync_enabled" checked>
                </div>
                <div class="control-group">
                    <label for="mouth_intensity">嘴巴开合强度:</label>
                    <input type="range" id="mouth_intensity" min="0.5" max="2.5" step="0.1" value="1.5">
                    <span id="mouth-value">1.5</span>
                </div>
                <div class="control-group">
                    <label for="blink_frequency">眨眼频率:</label>
                    <select id="blink_frequency">
                        <option value="high">高频率</option>
                        <option value="medium" selected>中频率</option>
                        <option value="low">低频率</option>
                        <option value="none">不眨眼</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Ollama 配置</div>
            <div class="model-config">
                <label for="llm_model">语言模型:</label>
                <select id="llm_model">
                    <option value="deepseek-r1:7b">deepseek-r1:7b</option>
                    <option value="qwen2:0.5b">Qwen2 0.5B</option>
                    <option value="llama2:7b">LLaMA2 7B</option>
                </select>
                
                <label for="temperature">温度:</label>
                <input type="range" id="temperature" min="0" max="1" step="0.1" value="0.7">
                
                <label for="top_p">Top P:</label>
                <input type="range" id="top_p" min="0" max="1" step="0.1" value="0.9">
            </div>
        </div>

        <div class="section">
            <div class="section-title">角色设定</div>
            <label for="role_prompt">角色设定:</label>
            <textarea id="role_prompt" rows="3" style="width: 100%">一个AI助手，会认真回答您的问题。</textarea>
        </div>

        <div class="section">
            <div class="section-title">对话</div>
            <div class="chat-container">
                <textarea id="text_talk" readonly placeholder="对话历史将显示在这里..."></textarea>
                <div class="chat-input">
                    <input type="text" id="user_input" placeholder="输入您的问题...">
                    <button id="send_message">发送</button>
                </div>
                <div class="audio-controls">
                    <button id="play_audio" disabled>播放语音</button>
                    <button id="stop_audio" disabled>停止语音</button>
                </div>
                <div id="audio-status"></div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">背景设置</div>
            
            <div class="tabs">
                <div class="tab active" data-tab="color">纯色背景</div>
                <div class="tab" data-tab="image">图片背景</div>
            </div>
            
            <div class="tab-content active" id="color-tab">
                <div class="bg-option">
                    <label for="bg_color">背景颜色:</label>
                    <input type="color" id="bg_color" value="#FFFFFF">
                </div>
                <button id="update_bg_color">更新背景颜色</button>
            </div>
            
            <div class="tab-content" id="image-tab">
                <select id="bg_image_preset">
                    <option value="">- 选择预设背景 -</option>
                    <option value="./backgrounds/classroom.jpg">教室</option>
                    <option value="./backgrounds/beach.jpg">海滩</option>
                    <option value="./backgrounds/forest.jpg">森林</option>
                    <option value="./backgrounds/space.jpg">太空</option>
                </select>
                
                <div class="bg-input-group">
                    <label for="bg_image_url">自定义背景图片URL:</label>
                    <input type="url" id="bg_image_url" placeholder="输入图片URL...">
                </div>
                <button id="update_bg_image">更新背景图片</button>
            </div>
        </div>
    </div>

    <!-- 添加LFS检查结果弹窗 -->
    <div id="lfs_dialog" class="dialog" style="display: none;">
        <div class="dialog-content">
            <span class="close-btn">&times;</span>
            <h3>模型文件检查结果</h3>
            <div id="lfs_check_result"></div>
            <div class="dialog-actions">
                <button id="close_lfs_dialog">关闭</button>
            </div>
        </div>
    </div>

    <script>
        // Live2D 模型配置
        const modelPaths = {
            'March 7th': './models/March 7th/March 7th.model3.json',
            'kei_vowels_pro': './models/kei_vowels_pro/kei_vowels_pro.model3.json',
            'Nova - F': './models/Nova - F/Nova - F.model3.json',
            'Hiyori': './models/Hiyori/Hiyori.model3.json',
            'pachan': './models/pachan/pachan.model3.json',
            'EVA RIN normal': './models/EVA RIN normal/EVA RIN normal.model3.json'
        };

        // 添加模型类型映射
        const modelTypes = {
            'March 7th': 'cubism4',
            'kei_vowels_pro': 'cubism4',
            'Nova - F': 'cubism4',
            'Hiyori': 'cubism4',
            'pachan': 'cubism4',
            'EVA RIN normal': 'cubism4'
        };

        // 添加情绪和动作系统
        const emotionKeywords = {
            '开心': ['高兴', '快乐', '欢喜', '喜悦', '兴奋', '愉快', '笑'],
            '悲伤': ['难过', '伤心', '哭', '忧伤', '悲痛', '难受', '苦恼', '不开心'],
            '惊讶': ['震惊', '吃惊', '惊讶', '意外', '没想到', '不可思议'],
            '生气': ['愤怒', '恼火', '不爽', '讨厌', '恨', '烦躁', '不悦'],
            '害羞': ['羞涩', '害羞', '不好意思', '腼腆', '难为情'],
            '疑惑': ['困惑', '疑问', '不解', '迷惑', '不明白', '不懂']
        };

        // 对应的表情和动作配置
        const expressionActions = {
            '开心': { 
                parameterIds: ['ParamMouthForm', 'ParamEyeLOpen', 'ParamEyeROpen', 'ParamBrowLY', 'ParamBrowRY'],
                parameterValues: [1, 0.8, 0.8, 0.5, 0.5],
                duration: 8000,  // 表情持续时间（毫秒）
                priority: 2      // 表情优先级
            },
            '悲伤': { 
                parameterIds: ['ParamMouthForm', 'ParamEyeLOpen', 'ParamEyeROpen', 'ParamBrowLY', 'ParamBrowRY'],
                parameterValues: [-0.8, 0.5, 0.5, -0.8, -0.8],
                duration: 10000,
                priority: 3
            },
            '惊讶': { 
                parameterIds: ['ParamMouthOpenY', 'ParamEyeLOpen', 'ParamEyeROpen', 'ParamBrowLY', 'ParamBrowRY'],
                parameterValues: [0.5, 1.2, 1.2, 1, 1],
                duration: 7000,
                priority: 3
            },
            '生气': { 
                parameterIds: ['ParamMouthForm', 'ParamEyeLOpen', 'ParamEyeROpen', 'ParamBrowLY', 'ParamBrowRY'],
                parameterValues: [-0.5, 0.8, 0.8, -1, -1],
                duration: 10000,
                priority: 3
            },
            '害羞': { 
                parameterIds: ['ParamMouthForm', 'ParamEyeLOpen', 'ParamEyeROpen', 'ParamBrowLY', 'ParamBrowRY'],
                parameterValues: [0.2, 0.7, 0.7, 0.2, 0.2],
                duration: 8000,
                priority: 2
            },
            '疑惑': { 
                parameterIds: ['ParamMouthForm', 'ParamEyeLOpen', 'ParamEyeROpen', 'ParamBrowLY', 'ParamBrowRY'],
                parameterValues: [0, 0.8, 0.8, -0.5, 0.5],
                duration: 6000,
                priority: 1
            }
        };

        // 口型同步参数配置
        const lipSyncParams = {
            // 控制嘴巴开合的参数
            mouthOpenY: 'ParamMouthOpenY',  // 嘴巴开合参数
            mouthForm: 'ParamMouthForm',    // 嘴巴形态参数
            // 眨眼相关参数
            eyeL: 'ParamEyeLOpen',          // 左眼开合参数
            eyeR: 'ParamEyeROpen',          // 右眼开合参数
            // 动画配置
            blinkInterval: [3000, 7000],    // 眨眼间隔范围（毫秒）
            blinkDuration: 100,             // 眨眼持续时间（毫秒）
            // 音频分析配置
            audioAnalysisInterval: 50,      // 音频分析间隔（毫秒）
            mouthOpenMax: 1.5,              // 嘴巴最大开度
            mouthOpenMin: 0.0,              // 嘴巴最小开度
            volumeThreshold: 0.01           // 音量阈值
        };

        // 添加动作配置
        const motionGroups = {
            '打招呼': ['motion/tap_head.motion3.json', 'motion/shake_body.motion3.json'],
            '点头': ['motion/nod.motion3.json'],
            '摇头': ['motion/shake_head.motion3.json'],
            '思考': ['motion/thinking.motion3.json'],
            '跳舞': ['motion/dance.motion3.json']
        };

        let currentModel;
        let app;
        let chatHistory = [];
        let currentAudio = null;
        let lastAudioUrl = null;
        let currentExpression = null;
        let expressionTimeout = null;
        let lipSyncActive = false;
        let lipSyncInterval = null;
        let lastBlinkTime = 0;
        let audioContext = null;
        let audioAnalyser = null;
        let audioDataArray = null;

        // 初始化模型选择下拉框
        const $modelSelect = $("#model_list");
        Object.keys(modelPaths).forEach(model => {
            $modelSelect.append($("<option>").attr("value", model).text(model));
        });

        // 音频控制函数
        function updateAudioStatus(message) {
            document.getElementById('audio-status').textContent = message;
        }

        function enableAudioControls(enabled = true) {
            document.getElementById('play_audio').disabled = !enabled;
            document.getElementById('stop_audio').disabled = !enabled || !currentAudio;
        }

        function playAudio() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
                stopLipSync();
            }

            if (lastAudioUrl) {
                currentAudio = new Audio(lastAudioUrl);
                currentAudio.volume = parseFloat(document.getElementById('volume').value);
                
                // 准备音频分析
                setupAudioAnalysis(currentAudio);
                
                currentAudio.onplay = () => {
                    enableAudioControls(true);
                    document.getElementById('play_audio').disabled = true;
                    document.getElementById('stop_audio').disabled = false;
                    updateAudioStatus('正在播放...');
                    // 开始口型同步
                    startLipSync();
                };
                
                currentAudio.onended = () => {
                    enableAudioControls(true);
                    document.getElementById('stop_audio').disabled = true;
                    updateAudioStatus('播放完成');
                    // 停止口型同步
                    stopLipSync();
                };

                currentAudio.onerror = () => {
                    updateAudioStatus('音频播放失败');
                    enableAudioControls(false);
                    stopLipSync();
                };
                
                currentAudio.play().catch(error => {
                    console.error('播放音频失败:', error);
                    updateAudioStatus('播放失败: ' + error.message);
                    stopLipSync();
                });
            }
        }

        function stopAudio() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
                document.getElementById('play_audio').disabled = false;
                document.getElementById('stop_audio').disabled = true;
                updateAudioStatus('已停止播放');
                // 停止口型同步
                stopLipSync();
            }
        }

        // 新增：音频分析和口型同步功能
        function setupAudioAnalysis(audio) {
            try {
                // 清理旧的分析器
                if (audioAnalyser) {
                    try {
                        audioAnalyser.disconnect();
                    } catch (e) {
                        console.log("断开旧分析器连接时出错:", e);
                    }
                    audioAnalyser = null;
                }
                
                // 确保AudioContext已初始化
                if (!audioContext) {
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        console.log("AudioContext已初始化");
                    } catch (error) {
                        console.error("初始化AudioContext失败:", error);
                        return;
                    }
                }
                
                if (audioContext.state === 'suspended') {
                    audioContext.resume().catch(err => {
                        console.error("恢复AudioContext失败:", err);
                    });
                }
                
                if (!audioContext || audioContext.state === 'closed') {
                    console.warn("AudioContext不可用，无法设置音频分析");
                    return;
                }
                
                // 创建媒体元素源和分析器
                const source = audioContext.createMediaElementSource(audio);
                audioAnalyser = audioContext.createAnalyser();
                audioAnalyser.fftSize = 256;
                
                // 连接音频节点：源 -> 分析器 -> 输出
                source.connect(audioAnalyser);
                audioAnalyser.connect(audioContext.destination);
                
                // 创建数据数组接收频域数据
                const bufferLength = audioAnalyser.frequencyBinCount;
                audioDataArray = new Uint8Array(bufferLength);
                
                console.log("音频分析器已设置完成");
                
            } catch (error) {
                console.error("设置音频分析失败:", error);
                if (error.name === "InvalidAccessError") {
                    console.error("可能是重复连接媒体源，尝试使用新的AudioContext");
                    audioContext = null;
                    audioAnalyser = null;
                    audioDataArray = null;
                    // 延迟重试一次
                    setTimeout(() => setupAudioAnalysis(audio), 100);
                    return;
                }
                audioAnalyser = null;
                audioDataArray = null;
            }
        }

        // 启动口型同步
        function startLipSync() {
            if (lipSyncActive || !currentModel) return;
            
            // 检查是否禁用了口型同步
            if (!$('#lipsync_enabled').is(':checked')) {
                return;
            }
            
            // 确保有效的音频分析器
            if (!audioAnalyser || !audioDataArray) {
                console.warn("音频分析器未准备好，无法启动口型同步");
                return;
            }
            
            lipSyncActive = true;
            lastBlinkTime = Date.now();
            
            console.log("开始口型同步");
            
            // 开始口型同步定时器
            lipSyncInterval = setInterval(() => {
                if (!currentAudio || currentAudio.paused) {
                    resetMouthParameters();
                    return;
                }
                
                try {
                    // 获取音频数据
                    audioAnalyser.getByteFrequencyData(audioDataArray);
                    
                    // 计算平均音量 (简单方法)
                    let sum = 0;
                    for (let i = 0; i < audioDataArray.length; i++) {
                        sum += audioDataArray[i];
                    }
                    const averageVolume = sum / audioDataArray.length / 255; // 归一化到0-1
                    
                    // 根据音量设置嘴型参数
                    if (averageVolume > lipSyncParams.volumeThreshold) {
                        const mouthOpen = lipSyncParams.mouthOpenMin + 
                                        (averageVolume * (lipSyncParams.mouthOpenMax - lipSyncParams.mouthOpenMin));
                                        
                        // 设置嘴巴开合度
                        setMouthParameters(mouthOpen);
                    } else {
                        // 音量低于阈值，关闭嘴巴
                        resetMouthParameters();
                    }
                    
                    // 随机眨眼
                    const now = Date.now();
                    if (now - lastBlinkTime > getRandomInt(lipSyncParams.blinkInterval[0], lipSyncParams.blinkInterval[1])) {
                        blinkEyes();
                        lastBlinkTime = now;
                    }
                } catch (error) {
                    console.error("口型同步更新失败:", error);
                }
                
            }, lipSyncParams.audioAnalysisInterval);
            
            console.log("已启动口型同步");
        }

        // 停止口型同步
        function stopLipSync() {
            if (lipSyncInterval) {
                clearInterval(lipSyncInterval);
                lipSyncInterval = null;
            }
            
            // 重置口型参数
            resetMouthParameters();
            lipSyncActive = false;
            console.log("已停止口型同步");
        }

        // 设置嘴型参数
        function setMouthParameters(openValue) {
            if (!currentModel) return;
            
            try {
                // 设置嘴巴开合度
                currentModel.internalModel.coreModel.setParameterValueById(
                    lipSyncParams.mouthOpenY, 
                    Math.min(Math.max(openValue, 0), lipSyncParams.mouthOpenMax)
                );
                
                // 微调嘴型形态，让动画更自然
                const formValue = openValue > 0.5 ? -0.2 : 0.1; // 嘴巴大开时收紧嘴角
                currentModel.internalModel.coreModel.setParameterValueById(
                    lipSyncParams.mouthForm, 
                    formValue
                );
            } catch (error) {
                console.warn("设置嘴型参数失败:", error);
            }
        }

        // 重置嘴型参数
        function resetMouthParameters() {
            if (!currentModel) return;
            
            try {
                // 重置嘴巴开合和形态
                currentModel.internalModel.coreModel.setParameterValueById(lipSyncParams.mouthOpenY, 0);
                currentModel.internalModel.coreModel.setParameterValueById(lipSyncParams.mouthForm, 0);
            } catch (error) {
                console.warn("重置嘴型参数失败:", error);
            }
        }

        // 眨眼动画
        function blinkEyes() {
            if (!currentModel) return;
            
            try {
                // 快速闭眼
                currentModel.internalModel.coreModel.setParameterValueById(lipSyncParams.eyeL, 0);
                currentModel.internalModel.coreModel.setParameterValueById(lipSyncParams.eyeR, 0);
                
                // 恢复睁眼
                setTimeout(() => {
                    currentModel.internalModel.coreModel.setParameterValueById(lipSyncParams.eyeL, 1);
                    currentModel.internalModel.coreModel.setParameterValueById(lipSyncParams.eyeR, 1);
                }, lipSyncParams.blinkDuration);
            } catch (error) {
                console.warn("眨眼动画失败:", error);
            }
        }

        // 辅助函数：获取指定范围内的随机整数
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // 背景控制函数
        function updateBackgroundColor(color) {
            document.getElementById('background').style.backgroundColor = color;
            document.getElementById('background').style.backgroundImage = 'none';
        }

        function updateBackgroundImage(url) {
            if (url) {
                document.getElementById('background').style.backgroundImage = `url('${url}')`;
            } else {
                alert('请输入有效的图片URL');
            }
        }

        // 加载Live2D模型
        async function loadModel(modelName) {
            try {
                console.log("开始清理旧模型资源...");
                // 清理现有模型的状态
                if (currentModel) {
                    console.log("发现旧模型，执行清理流程");
                    // 停止口型同步
                    stopLipSync();
                    
                    // 清理表情计时器
                    if (expressionTimeout) {
                        clearTimeout(expressionTimeout);
                        expressionTimeout = null;
                    }
                    
                    // 移除旧模型
                    console.log("从舞台移除旧模型");
                    app.stage.removeChild(currentModel);
                    
                    // 完全销毁模型实例
                    console.log("销毁旧模型资源");
                    if (typeof currentModel.destroy === 'function') {
                        currentModel.destroy({children: true, texture: true, baseTexture: true});
                    }
                    currentModel = null;
                    
                    // 强制垃圾回收提示
                    setTimeout(() => {
                        // 可选：手动执行一次浏览器垃圾回收
                        if (window.gc) window.gc();
                        console.log("旧模型清理完成");
                    }, 100);
                }
                
                // 初始化PIXI应用或清理舞台
                if (!app) {
                    console.log("创建PIXI应用");
                    // 创建PIXI应用
                    app = new PIXI.Application({
                        view: document.getElementById("canvas"),
                        autoStart: true,
                        resizeTo: window,
                        transparent: true,
                        backgroundAlpha: 0
                    });
                } else {
                    console.log("清理PIXI舞台");
                    // 清理舞台，移除所有子元素
                    while(app.stage.children.length > 0) {
                        const child = app.stage.getChildAt(0);
                        app.stage.removeChild(child);
                        if (typeof child.destroy === 'function') {
                            child.destroy({children: true, texture: true, baseTexture: true});
                        }
                    }
                }
                
                // 确保舞台是空的
                console.log("当前舞台子元素数量:", app.stage.children.length);
                
                // 获取模型路径
                const modelPath = modelPaths[modelName];
                console.log("准备加载新模型:", modelPath);
                
                // 检查模型类型
                let modelType = modelTypes[modelName] || 'cubism4';
                const isModelCubism2 = modelPath.endsWith('.model.json');
                const isModelCubism4 = modelPath.endsWith('.model3.json');
                
                // 根据文件扩展名确定实际类型
                if (isModelCubism2) modelType = 'cubism2';
                if (isModelCubism4) modelType = 'cubism4';
                
                console.log("模型类型:", modelType);
                
                // 根据类型选择加载方法
                let model;
                if (modelType === 'cubism2') {
                    // 使用Cubism 2引擎加载
                    console.log("使用Cubism 2引擎加载模型");
                    
                    // 检查是否加载了Cubism 2引擎
                    if (typeof Live2D === 'undefined') {
                        throw new Error("Cubism 2引擎未加载，无法加载Cubism 2模型");
                    }
                    
                    // 这里实现Cubism 2模型加载逻辑
                    // 注意：这需要完整的Cubism 2加载实现
                    alert("Cubism 2模型加载尚未完全实现，请使用Cubism 4模型");
                    throw new Error("Cubism 2模型加载尚未实现");
                } else {
                    // 使用Cubism 4引擎加载
                    console.log("使用Cubism 4引擎加载模型");
                    model = await PIXI.live2d.Live2DModel.from(modelPath);
                }
                
                console.log("模型加载完成，添加到舞台");
                app.stage.addChild(model);
                
                // 调整模型大小和位置
                const scale = Math.min(innerWidth / model.width, innerHeight / model.height);
                model.scale.set(scale);
                model.y = innerHeight * 0.1;
                model.x = innerWidth / 2;
                
                // 设置当前模型引用
                currentModel = model;
                
                // 添加交互能力
                model.on('hit', (hitAreas) => {
                    console.log('Touched area:', hitAreas);
                    if (hitAreas.includes('Head')) {
                        playModelMotion('打招呼');
                    } else if (hitAreas.includes('Body')) {
                        playModelMotion('点头');
                    }
                });
                
                // 加载默认表情
                setModelExpression('开心');
                
                // 记录加载成功
                console.log("模型加载成功:", modelName);
                return model;
            } catch (error) {
                console.error("加载模型失败:", error);
                
                // 记录详细错误信息
                if (error.message === "Invalid moc data") {
                    console.error("可能原因：模型格式与引擎不兼容，或模型文件损坏");
                    
                    // 发送错误信息到服务器进行记录
                    try {
                        await fetch('/api/log_model_error', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                model_path: modelPaths[modelName],
                                error: error.message,
                                stack: error.stack
                            })
                        });
                    } catch (logError) {
                        console.error("无法记录错误:", logError);
                    }
                    
                    // 提示用户
                    alert(`加载模型失败：模型格式可能与引擎不兼容\n请检查 ${modelName} 是否为Cubism 4格式的模型`);
                } else {
                    alert(`加载模型失败：${error.message}`);
                }
            }
        }

        // 新增：设置模型表情
        async function setModelExpression(expressionName) {
            if (!currentModel) return;
            
            try {
                const config = expressionActions[expressionName];
                if (!config) {
                    console.warn(`未找到表情配置: ${expressionName}`);
                    return;
                }
                
                // 检查是否应该覆盖当前表情
                if (currentExpression) {
                    const currentConfig = expressionActions[currentExpression];
                    if (currentConfig && currentConfig.priority > config.priority) {
                        console.log(`表情 ${expressionName} 优先级低于当前表情 ${currentExpression}，不切换`);
                        return;
                    }
                }
                
                // 清除之前的表情timeout
                if (expressionTimeout) {
                    clearTimeout(expressionTimeout);
                    expressionTimeout = null;
                }
                
                console.log(`设置表情: ${expressionName}`);
                
                // 使用参数控制设置表情
                if (config.parameterIds && config.parameterValues) {
                    for (let i = 0; i < config.parameterIds.length; i++) {
                        const paramId = config.parameterIds[i];
                        const paramValue = config.parameterValues[i];
                        
                        try {
                            // 使用补间动画平滑过渡
                            const currentValue = currentModel.internalModel.coreModel.getParameterValueById(paramId);
                            animateParameter(paramId, currentValue, paramValue, 300); // 300ms平滑过渡
                        } catch (paramError) {
                            console.warn(`设置参数失败 ${paramId}: ${paramError.message}`);
                            // 尝试直接设置
                            try {
                                currentModel.internalModel.coreModel.setParameterValueById(paramId, paramValue);
                            } catch (e) {
                                console.error(`设置参数彻底失败 ${paramId}: ${e.message}`);
                            }
                        }
                    }
                }
                
                currentExpression = expressionName;
                
                // 设置表情持续时间
                const duration = config.duration || 5000;
                
                // 定时恢复默认表情
                expressionTimeout = setTimeout(() => {
                    try {
                        // 平滑恢复默认表情参数
                        if (config.parameterIds) {
                            for (let i = 0; i < config.parameterIds.length; i++) {
                                const paramId = config.parameterIds[i];
                                const currentValue = currentModel.internalModel.coreModel.getParameterValueById(paramId);
                                animateParameter(paramId, currentValue, 0, 500); // 500ms平滑过渡到默认值
                            }
                        }
                        
                        console.log(`表情 ${expressionName} 已恢复默认状态`);
                        currentExpression = null;
                    } catch (e) {
                        console.warn("恢复默认表情失败:", e);
                    }
                    
                    expressionTimeout = null;
                }, duration);
                
            } catch (error) {
                console.error(`设置表情失败 ${expressionName}:`, error);
            }
        }
        
        // 参数动画函数：平滑过渡
        function animateParameter(paramId, startValue, targetValue, duration) {
            if (!currentModel) return;
            
            const startTime = Date.now();
            const animate = () => {
                if (!currentModel) return;
                
                const now = Date.now();
                const elapsed = now - startTime;
                
                if (elapsed >= duration) {
                    // 动画结束，设置最终值
                    currentModel.internalModel.coreModel.setParameterValueById(paramId, targetValue);
                    return;
                }
                
                // 计算当前进度（使用缓动函数）
                const progress = elapsed / duration;
                const easedProgress = 0.5 - 0.5 * Math.cos(Math.PI * progress);
                
                // 计算当前值
                const currentValue = startValue + (targetValue - startValue) * easedProgress;
                
                // 设置参数值
                currentModel.internalModel.coreModel.setParameterValueById(paramId, currentValue);
                
                // 继续动画
                requestAnimationFrame(animate);
            };
            
            // 启动动画
            animate();
        }
        
        // 新增：播放模型动作
        async function playModelMotion(motionType) {
            if (!currentModel) return;
            
            try {
                const motions = motionGroups[motionType];
                if (!motions || motions.length === 0) {
                    console.warn(`未找到动作组: ${motionType}`);
                    return;
                }
                
                // 随机选择一个动作
                const randomMotion = motions[Math.floor(Math.random() * motions.length)];
                console.log(`播放动作: ${motionType} - ${randomMotion}`);
                
                // 尝试播放动作
                try {
                    await currentModel.motion(motionType, randomMotion);
                } catch (motionError) {
                    console.warn(`无法使用motion方法播放动作: ${motionError.message}`);
                    
                    // 尝试通过组名播放
                    try {
                        await currentModel.motion(motionType);
                    } catch (groupError) {
                        console.error(`通过组名播放动作失败: ${groupError.message}`);
                    }
                }
            } catch (error) {
                console.error(`播放动作失败 ${motionType}:`, error);
            }
        }
        
        // 新增：分析文本情感并触发表情和动作
        function analyzeEmotionAndPlayAction(text) {
            if (!text || !currentModel) return;
            
            // 将文本转为小写并去除标点
            const normalizedText = text.toLowerCase().replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, "");
            
            // 检测情感关键词
            let detectedEmotion = null;
            let maxMatches = 0;
            
            for (const [emotion, keywords] of Object.entries(emotionKeywords)) {
                let matches = 0;
                for (const keyword of keywords) {
                    if (normalizedText.includes(keyword)) {
                        matches++;
                    }
                }
                
                if (matches > maxMatches) {
                    maxMatches = matches;
                    detectedEmotion = emotion;
                }
            }
            
            // 如果检测到情感，设置表情
            if (detectedEmotion && maxMatches > 0) {
                console.log(`检测到情感: ${detectedEmotion} (匹配度: ${maxMatches})`);
                setModelExpression(detectedEmotion);
                
                // 根据情感选择合适的动作
                if (detectedEmotion === '开心') {
                    playModelMotion('打招呼');
                } else if (detectedEmotion === '悲伤') {
                    playModelMotion('摇头');
                } else if (detectedEmotion === '惊讶') {
                    playModelMotion('跳舞');
                } else if (detectedEmotion === '疑惑') {
                    playModelMotion('思考');
                }
            }
        }

        // 发送消息并处理响应
        async function sendMessage(message) {
            const model = $("#llm_model").val();
            const temperature = parseFloat($("#temperature").val());
            const top_p = parseFloat($("#top_p").val());
            const rolePrompt = $("#role_prompt").val();
            const voiceId = $("#voice_selection").val();

            // 禁用发送按钮，显示加载状态
            $("#send_message").prop('disabled', true);
            $("#text_talk").val($("#text_talk").val() + '\n用户: ' + message + '\n助手: ');

            try {
                // 修复角色设定问题，确保角色设定与API正确对接
                console.log("发送请求，角色设定:", rolePrompt);
                
                const response = await fetch('/generate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        prompt: message,
                        role_prompt: rolePrompt,  // 添加单独的角色设定字段
                        session_id: null,  // 确保创建新会话
                        model_name: model,
                        temperature: temperature,
                        top_p: top_p,
                        voice_id: voiceId
                    })
                });

                if (!response.ok) {
                    throw new Error('API请求失败: ' + response.status);
                }

                const reader = response.body.getReader();
                let fullResponse = '';
                const textArea = document.getElementById('text_talk');
                
                // 设置思考表情和动作
                setModelExpression('疑惑');
                playModelMotion('思考');

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const text = new TextDecoder().decode(value);
                    const lines = text.split('\n').filter(line => line.trim());

                    for (const line of lines) {
                        try {
                            const data = JSON.parse(line);
                            if (data.chunk) {
                                fullResponse += data.chunk;
                                // 修复文本显示问题
                                const currentText = textArea.value;
                                const assistantPrefix = '助手: ';
                                const assistantStartPos = currentText.lastIndexOf(assistantPrefix);
                                
                                if (assistantStartPos !== -1) {
                                    textArea.value = currentText.substring(0, assistantStartPos + assistantPrefix.length) + fullResponse;
                                    textArea.scrollTop = textArea.scrollHeight;
                                }
                            }

                            if (data.done) {
                                lastAudioUrl = data.audio_url;
                                enableAudioControls(!!lastAudioUrl);
                                
                                // 分析响应文本，设置表情和动作
                                analyzeEmotionAndPlayAction(fullResponse);
                                
                                if (lastAudioUrl) {
                                    updateAudioStatus('语音生成完成');
                                    playAudio(); // 自动播放
                                } else {
                                    updateAudioStatus('未生成语音');
                                }
                            }
                        } catch (e) {
                            console.error('解析流数据失败:', e, line);
                        }
                    }
                }

                // 恢复按钮状态
                $("#send_message").prop('disabled', false);
            } catch (error) {
                console.error('发送消息失败:', error);
                $("#text_talk").val($("#text_talk").val() + '发送失败: ' + error.message);
                $("#send_message").prop('disabled', false);
                
                // 设置悲伤表情
                setModelExpression('悲伤');
            }
        }

        // 事件监听器
        $(document).ready(function() {
            // 加载可用模型列表
            loadAvailableModels();
            
            // 设置模型更新按钮
            setupModelUpdateButton();

            // 音量控制
            $("#volume").on('input', function() {
                const volume = parseFloat(this.value);
                $("#volume-value").text(Math.round(volume * 100) + '%');
                if (currentAudio) {
                    currentAudio.volume = volume;
                }
            });

            // 音频控制按钮
            $("#play_audio").click(function() {
                // 尝试初始化音频上下文（需要用户交互）
                initAudioContext();
                playAudio();
            });
            $("#stop_audio").click(stopAudio);

            // 发送消息按钮
            $("#send_message").click(function() {
                // 尝试初始化音频上下文（需要用户交互）
                initAudioContext();
                
                const message = $("#user_input").val().trim();
                if (message) {
                    sendMessage(message);
                    $("#user_input").val('');
                }
            });

            // 输入框回车发送
            $("#user_input").keypress(function(e) {
                if (e.which === 13) {
                    const message = $(this).val().trim();
                    if (message) {
                        sendMessage(message);
                        $(this).val('');
                    }
                    e.preventDefault();
                }
            });

            // 标签切换
            $(".tab").click(function() {
                $(".tab").removeClass("active");
                $(this).addClass("active");
                
                const tabId = $(this).data("tab");
                $(".tab-content").removeClass("active");
                
                if (tabId === "color") {
                    $("#color-tab").addClass("active");
                } else if (tabId === "image") {
                    $("#image-tab").addClass("active");
                }
            });

            // 更新背景颜色
            $("#update_bg_color").click(function() {
                const color = $("#bg_color").val();
                updateBackgroundColor(color);
            });

            // 更新背景图片
            $("#update_bg_image").click(function() {
                const customUrl = $("#bg_image_url").val().trim();
                const presetUrl = $("#bg_image_preset").val();
                
                const imageUrl = customUrl || presetUrl;
                if (imageUrl) {
                    updateBackgroundImage(imageUrl);
                } else {
                    alert("请选择预设图片或输入自定义图片URL");
                }
            });

            // 预设背景选择变化时自动更新
            $("#bg_image_preset").change(function() {
                const presetUrl = $(this).val();
                if (presetUrl) {
                    updateBackgroundImage(presetUrl);
                    $("#bg_image_url").val(''); // 清空自定义URL
                }
            });

            // 窗口大小改变时调整模型大小
            window.addEventListener('resize', function() {
                if (currentModel) {
                    const scale = Math.min(innerWidth / currentModel.width, innerHeight / currentModel.height);
                    currentModel.scale.set(scale);
                    currentModel.y = innerHeight * 0.1;
                    currentModel.x = innerWidth / 2;
                }
            });

            // 确保音频状态显示区域初始化
            updateAudioStatus('等待生成语音...');
            
            // 加载默认模型
            setTimeout(() => {
                const defaultModel = $("#model_list").val();
                checkAndLoadModel(defaultModel);
            }, 500);

            // 初始化AudioContext（需要用户交互触发）
            function initAudioContext() {
                if (!audioContext) {
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        console.log("AudioContext已创建");
                    } catch (error) {
                        console.error("创建AudioContext失败:", error);
                        return false;
                    }
                }
                
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log("AudioContext已恢复");
                    }).catch(error => {
                        console.error("恢复AudioContext失败:", error);
                    });
                }
                
                return true;
            }

            // 口型同步设置
            $('#lipsync_enabled, #mouth_intensity, #blink_frequency').on('change input', function() {
                updateLipSyncSettings();
            });
            
            // 初始化更新一次口型同步设置
            updateLipSyncSettings();
        });
        
        // 加载可用模型列表
        async function loadAvailableModels() {
            try {
                const response = await fetch('/get_model_list');
                if (!response.ok) {
                    throw new Error('获取模型列表失败');
                }
                
                const models = await response.json();
                console.log("服务器返回模型列表:", models);
                
                // 更新模型选择下拉框
                const $modelSelect = $("#model_list");
                $modelSelect.empty();
                
                models.forEach(model => {
                    modelPaths[model.name] = model.path;
                    modelTypes[model.name] = model.type;
                    $modelSelect.append($("<option>").attr("value", model.name).text(model.name));
                });
                
                // 如果没有模型，显示提示
                if (models.length === 0) {
                    alert("没有找到可用的Live2D模型，请确保模型文件夹存在并包含有效模型");
                } else {
                    // 加载默认模型
                    setTimeout(() => {
                        const defaultModel = $modelSelect.val();
                        if (defaultModel) {
                            checkAndLoadModel(defaultModel);
                        }
                    }, 500);
                }
            } catch (error) {
                console.error('加载模型列表失败:', error);
                alert('无法加载模型列表，请检查服务器状态');
            }
        }
        
        // 设置模型更新按钮事件
        function setupModelUpdateButton() {
            $("#update_model").click(function() {
                const selectedModel = $("#model_list").val();
                if (selectedModel) {
                    checkAndLoadModel(selectedModel);
                } else {
                    alert("请选择一个模型");
                }
            });
        }
        
        // 检查并加载模型
        async function checkAndLoadModel(modelName) {
            try {
                // 停止当前可能正在进行的模型相关活动
                if (currentModel) {
                    stopLipSync();
                    if (expressionTimeout) {
                        clearTimeout(expressionTimeout);
                        expressionTimeout = null;
                    }
                }
                
                const modelPath = modelPaths[modelName];
                if (!modelPath) {
                    alert(`找不到模型 ${modelName} 的路径配置`);
                    return;
                }
                
                console.log(`开始验证模型: ${modelName} (${modelPath})`);
                
                // 验证模型文件
                try {
                    const verifyResponse = await fetch(`/api/verify_model_files/${modelPath}`);
                    const verifyResult = await verifyResponse.json();
                    
                    console.log("模型验证结果:", verifyResult);
                    
                    if (!verifyResult.is_valid) {
                        let missingFiles = verifyResult.missing_files.join("\n- ");
                        alert(`模型 ${modelName} 缺少必要文件:\n- ${missingFiles}`);
                        return;
                    }
                    
                    if (verifyResult.model_type === "cubism2" && modelTypes[modelName] === "cubism4") {
                        alert(`警告: ${modelName} 是Cubism 2格式，但当前配置为使用Cubism 4引擎加载`);
                    }
                    
                    if (verifyResult.model_type === "cubism4" && modelTypes[modelName] === "cubism2") {
                        alert(`警告: ${modelName} 是Cubism 4格式，但当前配置为使用Cubism 2引擎加载`);
                    }
                    
                } catch (verifyError) {
                    console.warn(`验证模型文件失败: ${verifyError.message}, 尝试直接加载模型`);
                }
                
                // 加载模型 - 只在这一个地方调用loadModel
                console.log(`开始加载模型: ${modelName}`);
                await loadModel(modelName);
                
            } catch (error) {
                console.error('模型加载过程失败:', error);
                alert(`加载模型 ${modelName} 时出错: ${error.message}`);
            }
        }

        // 检查LFS指针
        async function checkLFSPointers() {
            try {
                const response = await fetch('/api/check_lfs_pointers');
                if (!response.ok) {
                    throw new Error('检查LFS指针失败');
                }
                
                const result = await response.json();
                console.log("LFS检查结果:", result);
                
                let html = '';
                
                if (result.lfs_pointers_found) {
                    html += `<div class="alert alert-danger">
                        <p><strong>发现Git LFS指针文件!</strong></p>
                        <p>您的模型文件是Git LFS指针，而不是实际的模型数据，这就是模型无法加载的原因。</p>
                    </div>`;
                    
                    html += `<h4>受影响的文件：</h4><ul>`;
                    result.files.forEach(file => {
                        html += `<li>${file.path} (当前大小: ${file.size} 字节, 预期大小: ${file.expected_size})</li>`;
                    });
                    html += `</ul>`;
                    
                    html += `<h4>解决方案：</h4>`;
                    
                    if (result.git_lfs_installed) {
                        html += `<p>1. Git LFS已安装，请运行以下命令拉取实际的模型文件：</p>
                        <pre>cd ${result.repo_path}
git lfs pull</pre>`;
                    } else {
                        html += `<p>1. 您需要安装Git LFS并拉取模型文件：</p>
                        <pre># 下载并安装Git LFS: https://git-lfs.github.com/
# 然后运行:
cd ${result.repo_path}
git lfs install
git lfs pull</pre>`;
                    }
                    
                    html += `<p>2. 或者，您可以从Live2D官方网站下载示例模型：</p>
                    <p><a href="https://www.live2d.com/en/download/sample-data/" target="_blank">https://www.live2d.com/en/download/sample-data/</a></p>`;
                } else {
                    html += `<div class="alert alert-success">
                        <p><strong>模型文件检查正常</strong></p>
                        <p>未发现Git LFS指针问题。请检查其他可能导致模型加载失败的因素：</p>
                        <ul>
                            <li>模型格式与引擎版本是否匹配 (Cubism 2 vs Cubism 4)</li>
                            <li>模型文件是否完整且未损坏</li>
                            <li>模型配置文件中的路径是否正确</li>
                        </ul>
                    </div>`;
                }
                
                // 显示结果
                document.getElementById('lfs_check_result').innerHTML = html;
                document.getElementById('lfs_dialog').style.display = 'block';
                
            } catch (error) {
                console.error('检查LFS指针失败:', error);
                alert(`检查模型文件失败: ${error.message}`);
            }
        }
        
        // 处理对话框关闭
        document.querySelector('.close-btn').addEventListener('click', function() {
            document.getElementById('lfs_dialog').style.display = 'none';
        });
        
        document.getElementById('close_lfs_dialog').addEventListener('click', function() {
            document.getElementById('lfs_dialog').style.display = 'none';
        });
        
        // 绑定检查按钮事件
        document.getElementById('check_lfs').addEventListener('click', checkLFSPointers);

        // 更新口型同步参数
        function updateLipSyncSettings() {
            const lipSyncEnabled = $('#lipsync_enabled').is(':checked');
            const mouthIntensity = parseFloat($('#mouth_intensity').val());
            const blinkFrequency = $('#blink_frequency').val();
            
            // 更新嘴巴开合强度
            lipSyncParams.mouthOpenMax = mouthIntensity;
            $('#mouth-value').text(mouthIntensity.toFixed(1));
            
            // 更新眨眼频率
            switch (blinkFrequency) {
                case 'high':
                    lipSyncParams.blinkInterval = [2000, 4000];
                    break;
                case 'medium':
                    lipSyncParams.blinkInterval = [3000, 7000];
                    break;
                case 'low':
                    lipSyncParams.blinkInterval = [6000, 12000];
                    break;
                case 'none':
                    lipSyncParams.blinkInterval = [1000000, 1000001]; // 实际上禁用眨眼
                    break;
            }
            
            // 处理启用/禁用状态
            if (!lipSyncEnabled && lipSyncActive) {
                stopLipSync();
            } else if (lipSyncEnabled && currentAudio && !currentAudio.paused && !lipSyncActive) {
                startLipSync();
            }
        }
    </script>
</body>
</html>
